<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="数据结构与算法[TOC] 第一章一、数据结构定义 计算机解决问题的过程 建立模型 构造求解算法 选择存储结构 编写程序 测试   算法 五类基本算法 贪婪算法 分而治之法 动态规划 回溯法 分支定界   其他高级算法 线性规划 整数规划 遗传算法 模拟退火等   非数值基础算法 穷举法 贪心法（Huffman树，以最小代价生成树的Prim算法和Kruskal算法 分治法（递归法） 回溯法（深度优先">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数据结构与算法[TOC] 第一章一、数据结构定义 计算机解决问题的过程 建立模型 构造求解算法 选择存储结构 编写程序 测试   算法 五类基本算法 贪婪算法 分而治之法 动态规划 回溯法 分支定界   其他高级算法 线性规划 整数规划 遗传算法 模拟退火等   非数值基础算法 穷举法 贪心法（Huffman树，以最小代价生成树的Prim算法和Kruskal算法 分治法（递归法） 回溯法（深度优先">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-05-09T18:14:57.201Z">
<meta property="article:modified_time" content="2021-05-12T16:55:43.471Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-数据结构与算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T18:14:57.201Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p>[TOC]</p>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="一、数据结构定义"><a href="#一、数据结构定义" class="headerlink" title="一、数据结构定义"></a>一、数据结构定义</h3><ol>
<li><h4 id="计算机解决问题的过程"><a href="#计算机解决问题的过程" class="headerlink" title="计算机解决问题的过程"></a>计算机解决问题的过程</h4><ol>
<li><strong>建立模型</strong></li>
<li><strong>构造求解算法</strong></li>
<li><strong>选择存储结构</strong></li>
<li><strong>编写程序</strong></li>
<li><strong>测试</strong></li>
</ol>
</li>
<li><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol>
<li>五类基本算法<ol>
<li><strong>贪婪算法</strong></li>
<li><strong>分而治之法</strong></li>
<li><strong>动态规划</strong></li>
<li><strong>回溯法</strong></li>
<li><strong>分支定界</strong></li>
</ol>
</li>
<li>其他高级算法<ol>
<li>线性规划</li>
<li>整数规划</li>
<li>遗传算法</li>
<li>模拟退火等</li>
</ol>
</li>
<li>非数值基础算法<ol>
<li>穷举法</li>
<li>贪心法（Huffman树，以最小代价生成树的Prim算法和Kruskal算法</li>
<li>分治法（递归法）</li>
<li>回溯法（深度优先、八皇后）</li>
<li>分支定界法（广度优先）</li>
<li>动态规划法（最佳二叉排序树）</li>
<li>å-ß裁剪和分支界限法</li>
<li>并行算法</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="数据结构研究对象"><a href="#数据结构研究对象" class="headerlink" title="数据结构研究对象"></a>数据结构研究对象</h4><ol>
<li>逻辑结构<ol>
<li>反映数据元素间的逻辑关系<ol>
<li><strong>线性结构</strong></li>
<li><strong>树结构</strong></li>
<li><strong>图结构</strong></li>
</ol>
</li>
</ol>
</li>
<li>存储结构<ol>
<li>反映数据元素及其关系在计算机存储器内的存储安排<ol>
<li><strong>顺序存储</strong></li>
<li><strong>链式存储</strong></li>
<li><strong>索引存储</strong></li>
<li><strong>散列存储</strong></li>
</ol>
</li>
</ol>
</li>
<li>运算对数据的最主要操作<ol>
<li><strong>增</strong></li>
<li><strong>删</strong></li>
<li><strong>改</strong></li>
<li><strong>查</strong></li>
</ol>
</li>
</ol>
</li>
<li><h4 id="不同数据结构操作集不同，但以下不可或缺"><a href="#不同数据结构操作集不同，但以下不可或缺" class="headerlink" title="不同数据结构操作集不同，但以下不可或缺"></a>不同数据结构操作集不同，但以下不可或缺</h4><ol>
<li>结构的生成</li>
<li>结构的销毁</li>
<li>在结构中查找满足规定条件的数据元素</li>
<li>在结构中插入新的数据元素</li>
<li>删除结构中已经存在的数据元素</li>
<li>遍历</li>
</ol>
</li>
<li><h4 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h4><ol>
<li>在计算机组织存储传递数据需讨论类和数据间的关系，以建立相应的数据结构，实现软件功能</li>
<li>数据结构描述现实世界实体的数据模型及其上的操作在计算机中的表示和实现</li>
<li>简单地说，<strong>数据结构是一门研究数值计算的程序设计问题中计算机操作对象及它们之间关系和操作等等的学科</strong><ol>
<li>数据结构是以某种特定的布局方式存储数据的容器</li>
<li>数据是计算机科学中最关键的载体而数据结构则可以将数据以某种形式存储</li>
<li>数据需要根据不同场景，按照特定的格式进行存储</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="二、基本概念和术语"><a href="#二、基本概念和术语" class="headerlink" title="二、基本概念和术语"></a>二、基本概念和术语</h3><ol>
<li><p>数据(Data)</p>
<ol>
<li><strong>被计算机识别和处理的符号集合</strong></li>
<li>包括<ol>
<li>数值性数据</li>
<li>非数值性数据</li>
</ol>
</li>
</ol>
</li>
<li><p>数据元素(data element)</p>
<ol>
<li><strong>数据基本单位</strong>。</li>
<li>一个数据元素由若干的数据项(data Item)组成</li>
<li>数据元素又称元素、结点、记录</li>
<li>例如：一个学生记录、树中期盼的一个格局（状态）、图中的一个顶点等</li>
</ol>
</li>
<li><p>数据项(data item)</p>
<ol>
<li><strong>是组成数据元素的</strong>、<strong>有独立含义的</strong>、<strong>不可分割的最小单位</strong></li>
<li>如：学生基本信息中的学号、姓名、性别等</li>
<li>数据项是具有独立含义的最小标识单位</li>
</ol>
</li>
<li><p>数据对象(data object)</p>
<ol>
<li><strong>具有相同性质的数据元素集合</strong><ol>
<li>举例<ol>
<li>整数数据对象<ol>
<li>N={0,+-1,+-2,…}</li>
</ol>
</li>
<li>字母字符数据对象<ol>
<li>C={‘A’,’B’,….’Z’}</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数据对象</p>
<ol>
<li>数据元素1<ol>
<li>数据项1</li>
</ol>
</li>
<li>数据元素2<ol>
<li>数据项1</li>
<li>数据项2</li>
</ol>
</li>
<li>数据元素3<ol>
<li>数据项1</li>
<li>数据项2</li>
<li>数据项3</li>
</ol>
</li>
</ol>
</li>
<li><p>数据结构(data structure)</p>
<ol>
<li>形式定义：<strong>数据结构是相互之间存在一种或者多种特定关系的数据元素的集合</strong></li>
<li>用二元组记为<ol>
<li>Data_Structure = {D,S}</li>
</ol>
</li>
<li>其中D为某一数据对象，S是该对象中所有数据乘员之间关系的有限集合</li>
<li>结构<ol>
<li>元素之间的关系称结构<ol>
<li>关系：描述的是数据元素之间的逻辑关系，称为数据的逻辑结构</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数据的逻辑结构</p>
<ol>
<li>从逻辑关系上描述数据，与数据存储无关</li>
<li>从具体问题抽象出来的数据模型</li>
<li>与数据元素本身的形式、内容无关</li>
<li>与数据元素的相对位置无关</li>
<li>数据的逻辑结构分类<ol>
<li>线性结构<ol>
<li>线性表</li>
</ol>
</li>
<li>非线性结构<ol>
<li>树</li>
<li>图（或网络）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数据的存储结构（物理结构）</p>
<ol>
<li>数据结构在计算机中的表示</li>
<li>数据的存储结构依赖于计算机语言<ol>
<li>顺序存储</li>
<li>链式存储</li>
<li>索引存储</li>
<li>散列存储</li>
</ol>
</li>
</ol>
</li>
<li><p>注意：</p>
<ol>
<li><p>数据的逻辑结构与存储结构密切相关</p>
<ol>
<li><p><strong>算法的设计取决于数据的逻辑结构</strong></p>
</li>
<li><p><strong>算法的实现取决于数据的物理结构</strong></p>
<blockquote>
<p>逻辑结构是数据元素之间的关系，存储结构是数据元素及其关系在计算机中的存储方式</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="三、抽象数据类型"><a href="#三、抽象数据类型" class="headerlink" title="三、抽象数据类型"></a>三、抽象数据类型</h3><ul>
<li><p>数据类型</p>
<ul>
<li>定义：一个值的集合和定义在这个值集上的一组操作的总称</li>
<li>C中基本的数据类型<ul>
<li>int char float double void</li>
</ul>
</li>
</ul>
</li>
<li><p>抽象数据类型</p>
<ul>
<li><p>是指一个数学模型及定义在此数学模型上的一组操作</p>
</li>
<li><p>数据结构+定义在此数据结构上的一组操作=抽象数据类型</p>
<ul>
<li><p>如:矩阵+（求转置、加、乘、求逆、求特征值）</p>
<p>构成一个矩阵的抽象数据类型</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据类型就是数据结构</p>
</li>
<li><p>数据类型是模版</p>
</li>
<li><p>基本数据类型可以看作是计算机中已实现的数据结构</p>
</li>
<li><p>构造数据类型由基本数据类型或构造数据类型组成</p>
</li>
<li><p>构造数据类型由不同分类型组成</p>
</li>
</ul>
<ol>
<li><p>抽象数据类型的形式定义</p>
<ol>
<li><p>抽象数据类型用三元组表示(D,S,P)</p>
<ol>
<li>D数据对象</li>
<li>S是D上的关系集</li>
<li>P是对D的基本操作集</li>
</ol>
</li>
<li><p>ADT抽象数据类型名 {</p>
<p>​    数据对象:&lt;数据对象的定义&gt;</p>
<p>​    数据关系:&lt;数据关系的定义&gt;</p>
<p>​    基本操作:&lt;基本操作的定义&gt;</p>
<p>}ADT抽象数据类型名</p>
</li>
</ol>
</li>
<li><p>ADT是指一个数据模型以及定义在该模型上的一组操作</p>
<ol>
<li>ADT<ol>
<li>数据逻辑结构</li>
<li>抽象运算</li>
</ol>
</li>
<li>对求解一个问题的形式化描述，面向用户，目的是使问题描述和问题实现相分离</li>
</ol>
</li>
<li><p>作用：有了ADT 程序员就可以将数据逻辑结构映射为存储结构，再在存储结构上设计抽象运算对应的算法，从而实现该ADT，一个数据类型可以看作是已经实现了抽象的数据类型。</p>
</li>
</ol>
<blockquote>
<p><strong>思考：数据类型与数据结构的区别和联系是什么？</strong></p>
<p>答:数据结构是相互之间存在一种成多种特定关系的数据元素的集合，一般包括数据逻辑结构、存储结构和数据的运算3方面的内容。</p>
<p>而数据类型是一个值的集合和定义在这个值集上的一组运算的总称，例如，C语言** *<em>short int</em>***数据类型(短整型)的值集合为-32768～32767，一组运算是+、-、*、/,%等.</p>
<p>可以将一种数据类型看成是一种实现了的数据结构。**</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><strong>数据结构的三个方面：</strong></li>
</ul>
<ol>
<li>数据的逻辑结构<ol>
<li>线性结构<ol>
<li>线性表</li>
<li>栈</li>
<li>队</li>
</ol>
</li>
<li>非线性结构<ol>
<li>树</li>
<li>图</li>
</ol>
</li>
</ol>
</li>
<li>数据的存储结构<ol>
<li>顺序存储</li>
<li>链式存储</li>
</ol>
</li>
<li>数据的操作<ol>
<li>增</li>
<li>删</li>
<li>改</li>
<li>查</li>
</ol>
</li>
</ol>
<ul>
<li>*<em>数据结构</em>***是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。</li>
<li>换句话说，数据结构是带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系。</li>
<li>或者说数据结构就是数据元素的组织形式。**</li>
</ul>
<h3 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h3><p><strong>1. 简述下列概念：数据、数据元素、数据项</strong></p>
<p><strong>数据对象、数据结构、逻辑结构、存储结构</strong></p>
<p><strong>抽象数据类型。</strong></p>
<p><strong>2. 写一个函数find，实现从数组a[n]查找元素x，返回x在数组中的序号，如果找不到则返回-1。</strong></p>
<p><strong>3. 当a[n]递增有序时，有没有高效的算法？</strong></p>
<p>1.</p>
<p>（1）数据：指的是在计算机科学中所有能输入到计算机中并被计算机程序处理的符号到总称。</p>
<p>（2）数据元素：是数据的基本单位。</p>
<p>（3）数据项：若干数据项可组成一个数据元素。</p>
<p>（4）数据对象：性质相同的数据元素的集合。</p>
<p>（5）数据结构：是相互之间存在一种或者多种特定关系的数据元素的集合。</p>
<p>（6）逻辑结构：数据元素之间的相互关系，可分为集合，线性结构，树形结构，图状结构。</p>
<p>（7）存储结构：包括数据元素的表示和关系的表示。分为顺序存储结构和链式存储结构。</p>
<p>（8）抽象数据类型：ADT=数据对象+数据关系+基本操作。</p>
<p>2.数组无序，采取遍历数组形式查找；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]==x)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(a);</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你想查找的整数\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">find</span>(a,n,x);</span><br><span class="line">    <span class="keyword">if</span> (k!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了，在索引%d位置&quot;</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.当有序时，可以采用二分查找法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = a[mid];</span><br><span class="line">        <span class="keyword">if</span> (middle &lt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (middle &gt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a);</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n请输人所要查找的元素：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">int</span> result = find(a, n, x);</span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了,在位置%d\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没找到\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、算法分析"><a href="#四、算法分析" class="headerlink" title="四、算法分析"></a>四、算法分析</h3><ul>
<li><p>算法：</p>
<ul>
<li>是对特定问题求解步骤的一种描述,是一个有穷的指令集，这些指令表示一个或多个操作</li>
<li>特性；<ul>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
<li>输入</li>
<li>输出</li>
</ul>
</li>
</ul>
</li>
<li><p>好算法的标准</p>
<ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效率与低存储</li>
</ul>
</li>
<li><p>算法的事前估计</p>
<ul>
<li>时间复杂度</li>
<li>运行时间=算法中每条语句执行时间之和</li>
<li>每条语句执行时间=该语句的执行次数*该语句执行一次所需要的时间</li>
</ul>
</li>
<li><p>常见算法时间复杂度</p>
<ul>
<li>O(1) : 表示算法的运行时间为常量</li>
<li> O(n) : 表示该算法是线性算法</li>
<li> O(logn): 二分查找算法</li>
<li> O(n2) : 对数组进行排序的各种简单算法，例如直接插入排序的算法。</li>
<li> O(n3) : 做两个n阶矩阵的乘法运算</li>
<li> O(2n) : 求具有n个元素集合的所有子集的算法</li>
<li> O(n!) : 求具有N个元素的全排列的算法</li>
</ul>
</li>
<li><p>**O(1)&lt;O(㏒n)&lt;O(n)&lt;O(**<strong>n㏒n)&lt; O(n2)&lt;)&lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn)</strong></p>
</li>
<li><p>空间复杂度</p>
<ul>
<li><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的度量，记作：</p>
</li>
<li><p>   S(n) = O(g(n))</p>
</li>
<li><p>表示随着问题规模n的增大，算法运行所需存储量的增长率与g(n)的增长率相同。</p>
</li>
<li><p>算法的存储量包括：</p>
<p>1．输入数据所占空间; </p>
<p>2．程序本身所占空间； </p>
<p>3．辅助变量所占空间。 </p>
</li>
</ul>
</li>
<li><p>存储空间的两个部分</p>
<ul>
<li><p><strong>存储空间的固定部分</strong>**</p>
<ul>
<li>程序指令代码的空间，常数、简单变量、定长成分(如数组元素、结构成分、对象的数据成员等)变量所占空间</li>
</ul>
</li>
<li><p>可变部分</p>
<ul>
<li> 尺寸与实例特性有关的成分变量所占空间、引用变量所占空间、递归栈所用空间、通过new和delete命令动态使用空间**</li>
</ul>
</li>
<li><p><strong>注意：一个算法的临时存储空间是指函数内新开辟的空间，不包括形参占用的空间</strong></p>
</li>
<li><p>```C<br>int fun (int a[], int n){ int i,s=0;<br>for(i=0; i=n; i++) </p>
<pre><code>s+=a[i];
</code></pre>
<p>return s; </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - **函数体内只开辟了****i，s变量空间，与n无关，所以空间复杂度为O(1)。不计形参a占用的空间。**</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### 作业二</span><br><span class="line"></span><br><span class="line">- **1.**   **以Niklus Wirth的观点，程序是什么?** </span><br><span class="line"></span><br><span class="line">  - **程序=数据结构+算法**</span><br><span class="line"></span><br><span class="line">- **2.**   **算法有什么特性？**</span><br><span class="line"></span><br><span class="line">  - **有穷性，确定性，可行性，输入，输出**</span><br><span class="line"></span><br><span class="line">- **3.**   **好算法应满足哪些标准？**</span><br><span class="line"></span><br><span class="line">  - **正确性，可读性，健壮性，高效率和低存储的需求**</span><br><span class="line"></span><br><span class="line">- **4.**   **数据结构主要在哪些层面上讨论问题？**</span><br><span class="line"></span><br><span class="line">  - **主要在逻辑结构，存储结构和运算这三个层面上讨论问题**</span><br><span class="line"></span><br><span class="line">- **5. 分析下列算法的时间复杂度**</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">   for(i=0;i&lt;n;i++)</span><br><span class="line">  </span><br><span class="line">    for(j=0;j&lt;m;j++)</span><br><span class="line">  </span><br><span class="line">     a[i][j]=0;</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p><strong>频度为m*n —n^2</strong></p>
</li>
<li><p>T(n)=O(n^2)</p>
</li>
</ul>
</li>
<li><p>```c<br> s=0;<br> for(i＝0; i＜n;i++)</p>
<p>  for(j＝0;j&lt;n;j++)</p>
<p>s+＝B[i][j]<br> sum=s;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - **频度为 2+n^2**</span><br><span class="line">  - **T(n)=O(n^2)**</span><br><span class="line"></span><br><span class="line">- **(3)**</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  i=1；</span><br><span class="line">   while(i&lt;=n)</span><br><span class="line">   i=i\*3;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>3^k=n 所以 k=log3 n</strong></li>
<li><strong>T(n)=O(log3 n)</strong></li>
</ul>
</li>
<li><p>```c<br> x=0;<br> for(i＝1;i＜n;i++)</p>
<p>  for(j＝1;j&lt;＝n-1;j++)</p>
<pre><code>x++;
</code></pre>
<p>sum=s;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - **频度为 n\*(n-1)**</span><br><span class="line">  - **T(n)=O(n^2)**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 第二章 线性表</span><br><span class="line"></span><br><span class="line">**1.** **了解线性结构的特点**</span><br><span class="line"></span><br><span class="line">**2.********掌握顺序表的定义、查找、插入和删除**</span><br><span class="line"></span><br><span class="line">**3.****掌握链表的定义、创建、查找、插入和删除**</span><br><span class="line"></span><br><span class="line">**4.****能够从时间和空间复杂度的角度比较两种存储结构的不同特点及其适用场合**</span><br><span class="line"></span><br><span class="line">1. 线性结构特点</span><br><span class="line"></span><br><span class="line">   在数据元素的非空有限集合中，同一线性表中元素具有相同特性，相邻元素之间存在序偶关系</span><br><span class="line"></span><br><span class="line">   1. 存在唯一一个被叫做第一个的数据元素</span><br><span class="line">   2. 存在唯一一个被叫做最后一个的数据元素</span><br><span class="line">   3. 除第一个元素外，每个数据元素均有唯一一个直接前驱</span><br><span class="line">   4. 除最后一个元素外，每个元素都有唯一一个直接后继</span><br><span class="line"></span><br><span class="line">2. 线性表</span><br><span class="line"></span><br><span class="line">   1. 是一种典型的线性结构</span><br><span class="line">   2. 数据的运算是定义在逻辑结构上的，而运算的具体实现则是在存储结构上进行的</span><br><span class="line"></span><br><span class="line">3. 线性表的存储结构</span><br><span class="line"></span><br><span class="line">   1. 顺序表</span><br><span class="line"></span><br><span class="line">      把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里，用这种方法存储的线性表简称顺序表</span><br><span class="line"></span><br><span class="line">      1. 逻辑上相邻，物理上也相邻</span><br><span class="line">      2. 顺序存储方法:用一组地址连续的存储单元存储线性表的元素，可通过数组V[n]实现</span><br><span class="line"></span><br><span class="line">   2. 顺序存储</span><br><span class="line"></span><br><span class="line">      1. 定义：将线性表中元素相继存放在一个连续的存储空间中</span><br><span class="line">      2. 存储结构：数组</span><br><span class="line">      3. 特点：顺序存储</span><br><span class="line">      4. 存取方式：随机存取</span><br><span class="line"></span><br><span class="line">4. 顺序表的存储结构定义</span><br><span class="line"></span><br><span class="line">### 静态分配的顺序表</span><br><span class="line"></span><br><span class="line">1. 静态分配的顺序表存储</span><br><span class="line"></span><br><span class="line">   1. ```c</span><br><span class="line">      #define  ListSize  100           //最大允许长度</span><br><span class="line">      typedef  struct &#123; </span><br><span class="line">              ListData  data[ListSize] ;      //存储空间</span><br><span class="line">              int  length;                      //当前元素个数</span><br><span class="line">          &#125; SeqList;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>静态存储的基本操作</p>
<p>1.InitList(&amp;L)；初始化线性表L为空表；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span> <span class="params">( SeqList  &amp;L )</span></span></span><br><span class="line"><span class="function"></span>&#123;                           <span class="comment">//初始化表L为空表</span></span><br><span class="line">     L.length = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>2、DestroyList(&amp;L)回收(销毁)线性表L</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span><span class="comment">//销毁线性表L </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (L.data)&#123;</span><br><span class="line">		<span class="keyword">delete</span> L.data;<span class="comment">//释放存储空间(删除此数组)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、 ClearList(&amp;L)  清空线性表L</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList</span><span class="params">(SeqList &amp;L)</span>     <span class="comment">//清空线性表L</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   L.length=<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 4、 **ListEmpty(SeqList **L) 判断线性表L是否为空，若为空返回1,否则返回0；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListEmpty</span><span class="params">(SeqList L)</span> </span>&#123;<span class="comment">//若线性表L为空返回1,否则返回****0**</span></span><br><span class="line">      <span class="keyword">return</span>(!(L.length)) ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 5、 ListLength ( L ) 求表L的长度 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span> <span class="params">( SeqList L )</span></span></span><br><span class="line"><span class="function"> </span>&#123;                            <span class="comment">//函数值是表L的长度</span></span><br><span class="line">  <span class="keyword">return</span>(L.length);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 6、 GetElem ( L, i ) 函数值为线性表L中第 i个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function">ListData <span class="title">GetElem</span> <span class="params">( SeqList L, <span class="keyword">int</span> i )</span> </span>&#123; <span class="comment">//函数值为表L中第 i 个元素</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>&lt;=i &amp;&amp; i &lt;= L.length )      </span><br><span class="line">    <span class="keyword">return</span> (L.data[i<span class="number">-1</span>]); <span class="comment">//第i-1的单元存储着第i个数据</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> “Error”;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 7-1、LocateElem( L, x ) 查找x在表L中的位置, 若查找成功，返回x的位置，否则返回-1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">( SeqList L, ListData x )</span> </span>&#123;<span class="comment">//查找x在表  </span></span><br><span class="line">      </span><br><span class="line">   <span class="comment">//L中位置, 若查找成功，返回x的位置，否则返回-1</span></span><br><span class="line">      </span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line"> <span class="keyword">while</span> ((i&lt;L.length)&amp;&amp;(L.data[i]!=x)) i++;  <span class="comment">//查找</span></span><br><span class="line">      </span><br><span class="line"> <span class="keyword">if</span> ( i&lt;L.length ) <span class="keyword">return</span> i;                  <span class="comment">//成功</span></span><br><span class="line">      </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;                           <span class="comment">//失败</span></span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7-2、 IsIn ( L, x ) 判断x是否在表L中，是返回1否则返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsIn</span> <span class="params">( SeqList L, ListData x )</span> </span>&#123; <span class="comment">//判断x是否在表L中</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">//x在L中返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, found=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((i&lt; L.length)&amp;&amp;!found )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(L.data[i]!= x ) i++;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">else</span> found=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> found;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、 NextElem (L, x ) 求x的直接后继</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextElem</span> <span class="params">( SeqList L, ListData x )</span> </span>&#123; <span class="comment">//如果x在表L中且</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//有直接后继，函数值返回其直接后继的位置，否则返回-1</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> ((i&lt;L.length)&amp;&amp;(L.data[i]!=x)) i++;  <span class="comment">//查找x</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ((<span class="number">0</span>&lt;=i)&amp;&amp;(i&lt;L.length<span class="number">-1</span>)) <span class="keyword">return</span> i+<span class="number">1</span>;      </span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>9、 PriorElem (L, x )求x的直接前驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PriorElem</span> <span class="params">( SeqList L, ListData x )</span> </span>&#123;  <span class="comment">//如果x在表L中且</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment">//有直接前驱，函数值返回其直接后继的位置，否则返回-1</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">while</span> (i&lt; L.length &amp;&amp; L.data[i]!=x) i++;     <span class="comment">//查找x</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> ((<span class="number">0</span>&lt; i)&amp;&amp;(i&lt;L.length)) <span class="keyword">return</span> i<span class="number">-1</span>;   <span class="comment">//返回位置</span></span><br><span class="line">      </span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10、ListInsert (&amp;L, i, x ) 在顺序表L中第 i 个元素前插入 x,插入成功返回1，不成功 返回0 n/2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span> <span class="params">( SeqList &amp;L, <span class="keyword">int</span> i , ListData x)</span> </span>&#123; <span class="comment">//在顺序表L中</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//第 i 个元素前插入 x,插入成功返回1，不成功 返回0</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ((i &lt; <span class="number">1</span>)||(i &gt;L.length+<span class="number">1</span>)||(L.length==ListSize))</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;                            <span class="comment">//插入不成功 </span></span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="keyword">for</span> ( <span class="keyword">int</span> j = L.length; j &gt;i<span class="number">-1</span>; j-- )           <span class="comment">//后移</span></span><br><span class="line">        L.data[j]=L.data[j<span class="number">-1</span>]; </span><br><span class="line">      L.data[i<span class="number">-1</span>]=x;  L.length++; <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//插入成功    </span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11、ListDelete (&amp;L, i) 在顺序表L中删除第i个元素删除成功返回1，否则返回0 (n-1)/2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span> <span class="params">( SeqList &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//在顺序表L中删除第i个元素,</span></span><br><span class="line">                          <span class="comment">//成功返回1，否则返回0</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span>)||(i&gt;L.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">L.length -- ; </span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> j = i<span class="number">-1</span>; j &lt; L.length+<span class="number">1</span>; j++ )    <span class="comment">//前移</span></span><br><span class="line">  L.data[j]=L.data[j+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;                      <span class="comment">//成功删除 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法时间复杂度分析</p>
<p>​    查找、插入、删除的平均时间复杂度为 O(n)</p>
<p>空间复杂度为S(n) = O(1) 没有占用辅助空间</p>
</li>
</ol>
</li>
</ul>
<h3 id="动态分配的顺序表"><a href="#动态分配的顺序表" class="headerlink" title="动态分配的顺序表"></a>动态分配的顺序表</h3><ol>
<li><p>动态分配的顺序表存储</p>
<ol>
<li><p>动态分配顺序存储结构</p>
<ol>
<li>```c<br>#define LIST_INIT_SIZE 10    // 线性表存储空间的初始分配量<br>#define LISTINCREMENT 5 // 线性表存储空间的分配增量<br> typedef struct<br> {<br>  ListData *data;     // 存储空间基址<br>  int length;     // 顺序表当前长度<br>  int listsize;// 当前分配的存储容量(以sizeof(ListData)为单位<br> }SqList;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 基本操作</span><br><span class="line"></span><br><span class="line">   1、InitList(&amp; L)；初始化线性表L为空表；</span><br><span class="line"></span><br><span class="line">   ```c</span><br><span class="line">   int InitList(SqList &amp;L)</span><br><span class="line">   &#123;                 // 分配指定大小的存储空间给顺序表</span><br><span class="line">    L.data = (ListData*)malloc(LIST_INIT_SIZE*sizeof(ListData));  //分配存储单元</span><br><span class="line">    if( !L.data )                  // 存储分配失败</span><br><span class="line">   		 exit(0);</span><br><span class="line">   L.length = 0;               // 当前长度初始化为0</span><br><span class="line">   L.listsize = LIST_INIT_SIZE; // 指定分配的存储容量 </span><br><span class="line">    return 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2、DestroyList(&amp;L) 回收顺序线性表L，将顺序表结构体中的所有成员销毁（空间释放， 数值置0）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;           <span class="comment">// 先释放空间，然后置空</span></span><br><span class="line"> <span class="built_in">free</span>( L.data );</span><br><span class="line"> L.length = <span class="number">0</span>;</span><br><span class="line"> L.listsize = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3、 ClearList(&amp;L)  清空线性表L</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">ClearList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;          <span class="comment">//清空线性表L</span></span><br><span class="line"> L.length = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 4、 ListEmpty(SeqList L) 判断线性表L是否为空，若为 </p>
<p>​    空返回1,否则返回0；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListEmpty</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">return</span>(!(L.length))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、 ListLength (L ) 求表L的长度 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// L.length记录当前顺序表的长度，直接返回</span></span><br><span class="line"><span class="keyword">return</span> (L.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 6、 GetElem ( L, i ) 函数值为表L中第 i个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListData <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//函数值为表L中                               //第 i 个元素</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">1</span>&lt;=i &amp;&amp; i &lt;= L.length )      </span><br><span class="line">    <span class="keyword">return</span> (*(L.data+i<span class="number">-1</span>));</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line"> &#125;     </span><br></pre></td></tr></table></figure>

<p>7-1、LocateElem(L, x ) 查找x在表L中的位置, 若查找成功，返回x的位置，否则返回-1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">( SqList L, ListData x )</span> </span>&#123;<span class="comment">//查找x在表  </span></span><br><span class="line">    <span class="comment">//L中位置, 若查找成功，返回x的位置，否则返回-1</span></span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> ((i&lt;L.length)&amp;&amp;(*(L.data+i)!=x)) i++;  <span class="comment">//查找</span></span><br><span class="line"> <span class="keyword">if</span> ( i&lt;L.length ) <span class="keyword">return</span> i;                  <span class="comment">//成功,返回位置</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;                          <span class="comment">//失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7-2、 IsIn ( L, x ) 判断x是否在表L中，是返回1否则返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsIn</span> <span class="params">( SqList L, ListData x )</span> </span>&#123; <span class="comment">//判断x是否在表L中</span></span><br><span class="line">               <span class="comment">//x在L中返回1，否则返回0</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, found=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((i&lt; L.length)&amp;&amp;!found )</span><br><span class="line">  <span class="keyword">if</span>(*(L.data+i)!= x ) i++;</span><br><span class="line">     <span class="keyword">else</span> found=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、 NextElem (L, x ) 求x的直接后继</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextElem</span> <span class="params">( SqList L, ListData x )</span> </span>&#123; <span class="comment">//如果x在表L中且</span></span><br><span class="line">   <span class="comment">//有直接后继，函数值返回其直接后继的位置，否则返回-1</span></span><br><span class="line"> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> ((i&lt;L.length)&amp;&amp;(*(L.data+i)!=x)) i++;  <span class="comment">//查找x</span></span><br><span class="line"> <span class="keyword">if</span> ((<span class="number">0</span>&lt;=i)&amp;&amp;(i&lt;L.length<span class="number">-1</span>)) <span class="keyword">return</span> i+<span class="number">1</span>;      </span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>9、 PriorElem (L, x )求x的直接前驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PriorElem</span> <span class="params">( SqList L, ListData x )</span> </span>&#123;  <span class="comment">//如果x在表L中且</span></span><br><span class="line">  <span class="comment">//有直接前驱，函数值返回其直接后继的位置，否则返回-1</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt; L.length &amp;&amp; *(L.data+i)!=x) i++;     <span class="comment">//查找x</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="number">0</span>&lt; i)&amp;&amp;(i&lt;L.length)) <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10、ListInsert (&amp;L, i, e) 在顺序表L中第 i 个元素前插入e,成功返回1，否则返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ListData e)</span></span></span><br><span class="line"><span class="function"></span>&#123;ListData *newbase, *q, *p;</span><br><span class="line"><span class="keyword">if</span>((i &lt; <span class="number">1</span>) || (i &gt; L.length + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">//输入的i不合法</span></span><br><span class="line"><span class="keyword">if</span>( L.length == L.listsize)              <span class="comment">// 当前存储空间已满, 增加分配空间</span></span><br><span class="line"> &#123;      <span class="comment">// realloc改变L.data所指内存的大小，原始所指内存中的数据不变。</span></span><br><span class="line">  newbase = (ListData *)<span class="built_in">realloc</span>(L.data, (L.listsize + LISTINCREMENT) * <span class="keyword">sizeof</span>(ListData));</span><br><span class="line">  <span class="keyword">if</span>( !newbase ) <span class="built_in">exit</span>(<span class="number">0</span>);                               <span class="comment">//申请新空间失败</span></span><br><span class="line">   L.data = newbase;                              <span class="comment">// 新基址</span></span><br><span class="line">   L.listsize += LISTINCREMENT;                  <span class="comment">// 增加存储容量</span></span><br><span class="line">  &#125;</span><br><span class="line"> q = L.data + i - <span class="number">1</span>;                                  <span class="comment">// 指定插入的位置</span></span><br><span class="line"> <span class="keyword">for</span>(p = L.data + L.length - <span class="number">1</span>; p &gt;= q; --p) *(p+<span class="number">1</span>) = *p;   <span class="comment">// q之后的元素右移</span></span><br><span class="line"> *q = e;  ++L.length; <span class="keyword">return</span> <span class="number">1</span>;             <span class="comment">// 插入e ，表长增1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11、ListDelete (&amp;L, i) 在顺序表L中删除第i个元素，成功返回1，否则返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123; ListData *p,*q;</span><br><span class="line">  <span class="keyword">if</span>( i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">// i值不合法</span></span><br><span class="line">  p = L.data + i - <span class="number">1</span>;  <span class="comment">// p为被删除元素的位置</span></span><br><span class="line">  q = L.data + L.length<span class="number">-1</span>;        <span class="comment">// 表尾元素的位置</span></span><br><span class="line">  <span class="keyword">for</span>(++p; p &lt;= q; ++p) <span class="comment">// 被删除元素之后的元素左移</span></span><br><span class="line"> *(p<span class="number">-1</span>) = *p;</span><br><span class="line"> L.length--; <span class="comment">// 表长减1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺序表的优缺点</p>
<ul>
<li>优点 <ul>
<li>存储密度大</li>
<li>可以随机存取表中任一元素</li>
</ul>
</li>
<li>缺点<ul>
<li>在插入删除某一元素时，需要移动大量元素</li>
<li>浪费存储空间</li>
<li>属于静态存储形式，数据元素的个数不能自由扩充</li>
<li>克服这一缺点-》链表</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="第二章作业一"><a href="#第二章作业一" class="headerlink" title="第二章作业一"></a>第二章作业一</h3><p>已知长度为n的线性表A采用顺序存储结构，请写一时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除线性表中所有值为item的数据元素。</p>
<p>解：</p>
<p>（1）算法思路</p>
<p>时间复杂度为O(n)即for 或者 while出现的次数最多为一次，空间复杂度为O(1)即在删除item过程中不能重新开辟一个数组，分配的空间不随处理数据量变化。则能想到用一个临时变量存储单次遍历中与item值不相同的值，并在当前循环中把值覆盖到原本线性表中从j==0开始的data[j]中，并且每次赋值后j递增1，遍历后所得的j即为新的线性表长度，最后赋值给length即完成顺序表删除相同元素并且改变线性表长度的操作。</p>
<p>（2）算法实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ListSize 10<span class="comment">//最大允许长度</span></span></span><br><span class="line"><span class="comment">//静态分配的顺序表存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ListData;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  ListData data[ListSize]; <span class="comment">//存储个数</span></span><br><span class="line">  <span class="keyword">int</span> length;<span class="comment">//当前元素个数</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//删除线性表中item值元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteItem</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> item)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp; <span class="comment">//储存临时变量</span></span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123; <span class="comment">//遍历顺序表</span></span><br><span class="line">    <span class="keyword">if</span>(L.data[i]!=item)&#123;</span><br><span class="line">      temp=L.data[i]; <span class="comment">//不等于item的线性表元素值存储到临时变量中</span></span><br><span class="line">      L.data[j]=temp; <span class="comment">//替换掉索引为j的线性表元素</span></span><br><span class="line">      j++; <span class="comment">//每替换一次 j的值加一</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  L.length=j; <span class="comment">//线性表长度缩小为j</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  SqList SL;</span><br><span class="line">  InitList(SL);</span><br><span class="line">  SL.length=<span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123; <span class="comment">//给线性表赋值，偶数索引对应值为2 单数索引对应值为1+i</span></span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">      j=<span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> j=<span class="number">1</span>+i;</span><br><span class="line">    SL.data[i]=j;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SL.length;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SL[%d]=%d\n&quot;</span>,i,SL.data[i]); <span class="comment">//打印顺序表中的值</span></span><br><span class="line">  &#125;</span><br><span class="line">  DeleteItem(SL, <span class="number">2</span>); <span class="comment">//删除item==2的顺序表元素</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SL.length;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SL[%d]=%d\n&quot;</span>,i,SL.data[i]); <span class="comment">//打印删除相同item后的顺序表</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性表的链式存储结构-链表-Linked-List"><a href="#线性表的链式存储结构-链表-Linked-List" class="headerlink" title="线性表的链式存储结构 链表(Linked List)"></a>线性表的链式存储结构 链表(Linked List)</h3><ul>
<li>单链表</li>
<li>静态链表</li>
<li>循环链表</li>
<li>双向链表</li>
</ul>
<p>链式存储有关术语</p>
<ol>
<li><p>结点：数据元素的存储映像，由数据域和指针域组成</p>
</li>
<li><p>链表：n个结点由指针链组成一个链表，它是线性表存储映像，称为线性表的链式存储结构</p>
</li>
<li><p>单链表、双链表、循环链表：</p>
<ol>
<li>结点只有一个指针域，称为单链表或线性链表</li>
<li>有两个指针域的链表，称为双链表</li>
<li>首尾相接的链表称为循环链表</li>
</ol>
</li>
<li><p>头指针、头结点和首元节点:</p>
<ol>
<li>头指针是指向链表中第一个结点的指针</li>
<li>首元结点是指链表中存储第一个数据元素a1的结点</li>
<li>头结点是在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信息</li>
</ol>
</li>
<li><p>在链表中设置头节点有什么好处</p>
<ol>
<li>便于首元结点处理</li>
<li>便于空表和非空表的统一处理</li>
</ol>
</li>
<li><p>头结点的数据域内装的是什么</p>
<ol>
<li>头结点的数据域可以为空，也可存放线性表长度等附加信息，但此结点不可以计入链表长度值</li>
</ol>
</li>
<li><p>链式（链式存储结构）的特点</p>
<ol>
<li>结点在存储器的位置不是任意的，即逻辑上相邻的数据元素在物理上的不一定相邻</li>
<li>访问时只能通过头指针进入链表，并通过每个结点的结点的指针域后扫描其余结点，所以寻找第一个结点和最后一个结点所话费的时间不等</li>
<li>顺序存储</li>
</ol>
<p>链表的优缺点</p>
<ul>
<li>优点<ul>
<li>数据元素的个数可以自由扩充</li>
<li>插入、删除等操作不必移动元素，只需修改链接指针，修改效率较高</li>
</ul>
</li>
<li>缺点<ul>
<li>存储密度小</li>
<li>存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表结构定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ListData;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>              <span class="comment">//链表结点 </span></span><br><span class="line">   ListData  data;            <span class="comment">//结点数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">next</span>;</span>            <span class="comment">//结点链域</span></span><br><span class="line"> &#125; ListNode;</span><br><span class="line"><span class="keyword">typedef</span> ListNode * LinkList;      <span class="comment">//链表头指针</span></span><br></pre></td></tr></table></figure>

<p>1.InitList(&amp;first)；初始化单链表first为空表；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(LinkList  &amp;first)</span></span>&#123;  <span class="comment">//初始化单链表first为空表</span></span><br><span class="line">    first=<span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>2、DestroyList(&amp;first) 销毁单链表first</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(LinkList &amp;first)</span> </span>&#123;</span><br><span class="line">                      <span class="comment">//删去单链表first的所有结点</span></span><br><span class="line">  ListNode *q;</span><br><span class="line">  <span class="keyword">while</span> (first ) &#123;</span><br><span class="line">              <span class="comment">//当链不空时，循环逐个删去所有结点</span></span><br><span class="line">     q =first；first= first→next;</span><br><span class="line">    <span class="built_in">free</span>( q );    <span class="comment">//释放 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3、 ClearList(&amp;first)  清空单链表first</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span> <span class="params">( LinkList  &amp;first )</span> </span>&#123;</span><br><span class="line">                      <span class="comment">//删去单链表first中所有结点</span></span><br><span class="line">  ListNode *q;</span><br><span class="line">  <span class="keyword">while</span> (first ) &#123;</span><br><span class="line">              <span class="comment">//当链不空时，循环逐个删去所有结点</span></span><br><span class="line">     q =first; first = first→next;</span><br><span class="line">    <span class="built_in">free</span>( q );    <span class="comment">//释放 </span></span><br><span class="line">   &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 4、 ListEmpty(first) 判断单链表first是否为空，若为空返回1, 否则返回0；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListEmpty</span><span class="params">(LinkList first)</span></span></span><br><span class="line"><span class="function"> </span>&#123;            <span class="comment">//若单链表first为空返回1,否则返回0</span></span><br><span class="line">    <span class="keyword">return</span> !first ;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>5、 ListLength ( first ) 求单链表first的长度 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(LinkList first)</span>  <span class="comment">//函数值为单链表first长度</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p=first;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">      p=p→next;     count++;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> 6、 GetElem ( first, i ) 函数值为单链表first中第 i个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListData <span class="title">GetElem</span><span class="params">(LinkList first, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//函数返回单链表first中第i个元素值，不存在返回NULL</span></span><br><span class="line">  LinkList p;    <span class="keyword">int</span> j;</span><br><span class="line">  p=first; j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (p&amp;&amp;(j&lt;i)) &#123;               <span class="comment">//找第i个元素</span></span><br><span class="line">    p=p→next; ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!p||j&gt;i) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">//第i个元素不存在,p 空没找到</span></span><br><span class="line">                        <span class="comment">//j&gt;i 是输入i&lt;1的情况</span></span><br><span class="line">  <span class="keyword">return</span> p→data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 7-1、LocateElem( first, x ) 查找x在单链表first中位置, 若查找成功，返回x的位置，否则返回NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">LocateElem</span><span class="params">( LinkList first, ListData x )</span> </span>&#123;<span class="comment">//在单链表first中</span></span><br><span class="line">    <span class="comment">//搜索数据值为x的结点，成功返回x第一次出现的位置，否则返回NULL</span></span><br><span class="line">   ListNode * p = first;        <span class="comment">//指针 p 指示第一个结点</span></span><br><span class="line">   <span class="keyword">while</span> ( p &amp;&amp; (p→data != x)) </span><br><span class="line">     p = p→next;</span><br><span class="line">   <span class="keyword">return</span> p;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7-2、 IsIn ( first, x ) 若x在单链表first中函数返回1否则返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">IsIn</span> <span class="params">(( LinkList first, ListData x )</span></span></span><br><span class="line"><span class="params"><span class="function">  &#123;               <span class="comment">//若x在单链表first中函数返回1否则返回0</span></span></span></span><br><span class="line"><span class="params"><span class="function">  ListNode * p = first;            <span class="comment">//指针 p 指示第一个结点</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">while</span> ( p &amp;&amp; (p→data != x))    <span class="comment">//找x</span></span></span></span><br><span class="line"><span class="params"><span class="function">    p = p→next;</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">return</span> !(p==<span class="literal">NULL</span>);   </span></span></span><br><span class="line"><span class="params"><span class="function">&#125; </span></span></span><br></pre></td></tr></table></figure>

<p>8、 NextElem (first, x ) 求x的直接后继</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">NextElem</span><span class="params">(LinkList first, ListData x)</span> </span>&#123; </span><br><span class="line">  <span class="comment">//函数返回单链表//first中值为x结点的直接后继结点地址，没有返回NULL</span></span><br><span class="line"> LinkList p=first;</span><br><span class="line"> <span class="keyword">while</span>(p&amp;&amp;p→data!=x)              <span class="comment">//找x</span></span><br><span class="line">     p=p→next;</span><br><span class="line"> <span class="keyword">if</span> (!p || ! p→next) <span class="keyword">return</span> <span class="literal">NULL</span>;      <span class="comment">//没有直接后继</span></span><br><span class="line"> <span class="keyword">return</span> p→next;          </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>9、 PriorElem (first, x )求x的直接前驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">PriorElem</span><span class="params">(LinkList first, ListData x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     <span class="comment">//函数返回x的直接前驱的结点地址，没有返回NULL</span></span><br><span class="line"> LinkList p=first;</span><br><span class="line"> <span class="keyword">while</span>(p&amp;&amp;p→next &amp;&amp;(p→next→data!=x))        <span class="comment">//找x</span></span><br><span class="line">     p=p→next;</span><br><span class="line"> <span class="keyword">if</span> (!p ||! p→next) <span class="keyword">return</span> <span class="literal">NULL</span>;         <span class="comment">//没有直接前驱</span></span><br><span class="line"> <span class="keyword">return</span> p;          </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>10、 ListInsert (&amp;first, i, x )在单链表first第 i 个元素结点前插入元素 x</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span> <span class="params">( LinkList &amp;first, <span class="keyword">int</span> i, ListData x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在单链表first中第 i 个元素结点前插入元素 x，成功返回1否则返回0</span></span><br><span class="line"> newnode=(ListNode *) <span class="built_in">malloc</span> ( <span class="keyword">sizeof</span> (ListNode) );</span><br><span class="line"> newnode→data = x;                 <span class="comment">//创建新结点</span></span><br><span class="line"> <span class="keyword">if</span> (i==<span class="number">1</span>) &#123;                   <span class="comment">//插入为第一个结点</span></span><br><span class="line">     newnode→next = first;         <span class="comment">//新结点成为第一个结点</span></span><br><span class="line">     first = newnode;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">   &#125; </span><br><span class="line"> p = first;  k = <span class="number">1</span>; &#123;     <span class="comment">//插入位置不是第一个结点</span></span><br><span class="line"> <span class="keyword">while</span> ( p &amp;&amp; k &lt; i<span class="number">-1</span>) </span><br><span class="line">   &#123; p = p→next; k++; &#125;  <span class="comment">//移动指针，找第 i-1个结点</span></span><br><span class="line"> <span class="keyword">if</span> ( !p || i&lt;<span class="number">1</span>) ) &#123; </span><br><span class="line">   <span class="built_in">printf</span> ( “无效的插入位置!\n” );        <span class="comment">//终止插入</span></span><br><span class="line">     <span class="built_in">free</span>(newnode);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> newnode→next = p→next;       </span><br><span class="line"> p→next = newnode;              <span class="comment">//插在表中间或末尾</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11、ListDelete (&amp;first, i )在单链表first中删除第 i 个结点，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span> <span class="params">( LinkList &amp;first, <span class="keyword">int</span> i )</span> </span>&#123; </span><br><span class="line">        <span class="comment">//在单链表first中删除第 i 个结点，删除成功返回1否则返回0</span></span><br><span class="line">  <span class="keyword">if</span> ( first&amp;&amp;i == <span class="number">1</span> )             <span class="comment">//删除表中第 1 个结点</span></span><br><span class="line">    &#123; q = first; first = first→next; &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    p = first;  k = <span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">while</span> ( p &amp;&amp; k &lt; i<span class="number">-1</span> )</span><br><span class="line">      &#123; p = p→next; k++; &#125;           <span class="comment">//找第 i-1个结点</span></span><br><span class="line">          <span class="keyword">if</span> ( !p  || !(p→next) || i&lt;<span class="number">1</span> ) &#123;                                                                                            <span class="comment">//找不到第i-1个结点</span></span><br><span class="line">            <span class="built_in">printf</span> ( “无效的删除位置!\n” );</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;q = p→next;                     <span class="comment">//删除中间结点或尾结点元素         </span></span><br><span class="line">                 p→next = q→next;        </span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">free</span> ( q ); <span class="keyword">return</span> <span class="number">1</span>;                                      <span class="comment">//释放q</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带头节点的单链表基本操作</p>
<p>1、InitList(&amp;first)；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化带头结点单链表first；</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(LinkList &amp;first)</span></span>&#123; </span><br><span class="line">                   <span class="comment">//初始化带头结点的单链表first为空表</span></span><br><span class="line">  first = (ListNode *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (ListNode) );  <span class="comment">//创建头结点 </span></span><br><span class="line">  first→next=<span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>2、DestroyList(&amp;first) 销毁带头节点单链表first</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(LinkList &amp;first)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//删去带头节点单链表first中的所有结点，包括头结点</span></span><br><span class="line">  ListNode *q;</span><br><span class="line">  <span class="keyword">while</span> (first ) &#123;</span><br><span class="line">              <span class="comment">//当链不空时，循环逐个删去所有结点</span></span><br><span class="line">     q =first；first= first→next;</span><br><span class="line">    <span class="built_in">free</span>( q );    <span class="comment">//释放 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3、 ClearList(&amp;first)  清空带头结点单链表first</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span> <span class="params">( LinkList  &amp;first )</span> </span>&#123;   <span class="comment">// 将表重置为空表</span></span><br><span class="line">          <span class="comment">//删去带头结点单链表first中的所有结点，保留头结点</span></span><br><span class="line"> ListNode *p, *q=first→next;</span><br><span class="line"> <span class="keyword">while</span> (q ) &#123;          <span class="comment">//当链不空时，循环逐个删去所有结点</span></span><br><span class="line">    p=q; q=q→next;</span><br><span class="line">   <span class="built_in">free</span>( p );          <span class="comment">//释放 </span></span><br><span class="line">  &#125; ;</span><br><span class="line"> first→next=<span class="literal">NULL</span>;   <span class="comment">//头结点指针域为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 4、 ListEmpty(LinkList first) 判断带头结点单链表first是否为空，若为空返回1,否则返回0；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListEmpty</span><span class="params">(LinkList first)</span></span></span><br><span class="line"><span class="function"> </span>&#123;            <span class="comment">//若带头结点单链表first为空返回1,否则返回0</span></span><br><span class="line">    <span class="keyword">return</span> !(first→next) ;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>5、 ListLength ( first ) 求带头结点单链表first的长度 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(LinkList first)</span> <span class="comment">//函数返回带头结点单链表first长度</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    p=first→next;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">      p=p→next;     count++;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> 6、 GetElem ( first, i ) 函数值为带头结点单链表first中第 i个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListData <span class="title">GetElem</span><span class="params">(LinkList first,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//函数返回带头结点单链表first第i个元素值，不存在返回NULL</span></span><br><span class="line">   LinkList p;    <span class="keyword">int</span> j;</span><br><span class="line">   p=first→next; j=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (p&amp;&amp;(j&lt;i)) &#123;               <span class="comment">//找第i个元素</span></span><br><span class="line">     p=p→next; ++j;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!p||j&gt;i) <span class="keyword">return</span> <span class="literal">NULL</span>;              <span class="comment">//第i个元素不存在</span></span><br><span class="line">   <span class="keyword">return</span> p→data;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 7-1、LocateElem( first, x ) 查找x在带头结点单链表first中的位置, 若查找成功，返回x的位置，否则返回NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">LocateElem</span><span class="params">( LinkList first, ListData x )</span> </span>&#123; <span class="comment">//在带头结点单//链表first中搜索其值为x的结点，查找成功返回x位置，否则返回NULL</span></span><br><span class="line">   ListNode * p = first→next;        <span class="comment">//指针 p 指示第一个结点</span></span><br><span class="line">   <span class="keyword">while</span> ( p &amp;&amp; (p→data != x)) </span><br><span class="line">     p = p→next;</span><br><span class="line">   <span class="keyword">return</span> p;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7-2、 IsIn ( first, x ) 若x在带头结点单链表first中函数返回1否则返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">IsIn</span> <span class="params">( LinkList first, ListData x )</span></span></span><br><span class="line"><span class="function">  </span>&#123;         <span class="comment">//若x在带头结点单链表first中函数返回1否则返回0</span></span><br><span class="line">  ListNode * p = first→next;            <span class="comment">//指针 p 指示第一个结点</span></span><br><span class="line">  <span class="keyword">while</span> ( p &amp;&amp; (p→data != x)) </span><br><span class="line">    p = p→next;</span><br><span class="line">  <span class="keyword">return</span> !(p==<span class="literal">NULL</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、 NextElem (first, x ) 在带头结点单链表first中求x的直接后继</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">NextElem</span><span class="params">(LinkList first, ListData x)</span> </span>&#123; <span class="comment">//函数返回带头结点单链表first中x的直接后继的结点地址，没有返回NULL</span></span><br><span class="line"> LinkList p=first→next;</span><br><span class="line"> <span class="keyword">while</span>(p&amp;&amp;p→data!=x)              <span class="comment">//找x</span></span><br><span class="line">     p=p→next;</span><br><span class="line"> <span class="keyword">if</span> (!p || ! p→next) <span class="keyword">return</span> <span class="literal">NULL</span>;      <span class="comment">//没有直接后继</span></span><br><span class="line"> <span class="keyword">return</span> p→next;          </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>9、 PriorElem (first, x )在带头结点单链表first中求x的直接前驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">PriorElem</span><span class="params">(LinkList first, ListData x)</span> </span>&#123; <span class="comment">//函数返回带头结点单链表first中x的直接前驱的结点地址，没有返回NULL</span></span><br><span class="line">LinkList p=first→next;</span><br><span class="line"> <span class="keyword">while</span>(p&amp;&amp;p→next &amp;&amp;(p→next→data!=x))           <span class="comment">//找x</span></span><br><span class="line">     p=p→next;</span><br><span class="line"> <span class="keyword">if</span> (!p||!p→next) <span class="keyword">return</span> <span class="literal">NULL</span>;              <span class="comment">//没有直接前驱 </span></span><br><span class="line"> <span class="keyword">return</span> p;         </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>10、 ListInsert (first, i, x) 在带头节点单链表first第 i 个元素结点前插入元素 x</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span> <span class="params">(LinkList first, ListData x, <span class="keyword">int</span> i )</span> </span>&#123;</span><br><span class="line">           <span class="comment">//在带头节点的单链表first中第 i 个元素结点前插入元素 x，成功返回1否则返回0</span></span><br><span class="line">  p = first;  k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( p &amp;&amp; k &lt; i <span class="number">-1</span> ) </span><br><span class="line">    &#123; p = p→next; k++; &#125;                        <span class="comment">//寻找第 i-1个结点</span></span><br><span class="line">  <span class="keyword">if</span> ( !p || i&lt;<span class="number">1</span>) ) &#123; </span><br><span class="line">    <span class="built_in">printf</span> ( “无效的插入位置!\n” );                  <span class="comment">//终止插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;                                        <span class="comment">//参数i值不合理返回0</span></span><br><span class="line">  newnode = (ListNode *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (ListNode) );    <span class="comment">//创建新结点</span></span><br><span class="line">  newnode→data = x; </span><br><span class="line">  newnode→next = p→next;                  <span class="comment">//插入新结点</span></span><br><span class="line">  p→next = newnode;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11、 ListDelete (first, i ) 删除带头节点单链表first的第 i 个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span> <span class="params">( LinkList first, <span class="keyword">int</span> i )</span> </span>&#123;</span><br><span class="line">         <span class="comment">//删除带头节点单链表first的第 i 个元素，成功返回1否则返回0</span></span><br><span class="line"> p=first; k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (p &amp;&amp; k++&lt;i<span class="number">-1</span>) p= p→next;  <span class="comment">//寻找第i-1个结点</span></span><br><span class="line">  <span class="keyword">if</span> ( !p ||!( p→next )|| i&lt;<span class="number">1</span>) </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;                     <span class="comment">//i值不合理或空表 </span></span><br><span class="line">   q = p→next;  </span><br><span class="line"> p→next = q→next;               <span class="comment">//删除结点</span></span><br><span class="line">  <span class="built_in">free</span> ( q );                    <span class="comment">//释放</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">createListF</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;<span class="comment">//创建带头结点单链表，函数返回</span></span><br><span class="line">                                    <span class="comment">//单链表的头指针</span></span><br><span class="line">  head =                    <span class="comment">//建立表头结点</span></span><br><span class="line">    (LinkList) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (ListNode));</span><br><span class="line">  head→next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( (ch = getchar( ) ) != ‘\n’ ) &#123;</span><br><span class="line">     q = (listNode *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">     q→data = ch;                      <span class="comment">//建立新结点</span></span><br><span class="line">    q→next = head→next;             <span class="comment">//插入到表前端</span></span><br><span class="line">     head→next = q;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">createListR</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;&#123;<span class="comment">//创建带头结点单链表，函数返回</span></span><br><span class="line">                                    <span class="comment">//单链表的头指针</span></span><br><span class="line">  head =(LinkList) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (ListNode));</span><br><span class="line">  r = head;                <span class="comment">//建立表头结点，r 指向表尾</span></span><br><span class="line"> <span class="keyword">while</span> ( (ch = getchar( ) ) != ‘\n’ ) &#123;</span><br><span class="line">    q = (listNode *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">     q→data = ch;                        <span class="comment">//建立新结点</span></span><br><span class="line">     r →next = q;  r =q;                  <span class="comment">//插入到表末端</span></span><br><span class="line">  &#125;</span><br><span class="line">  r →next = <span class="literal">NULL</span>;    <span class="keyword">return</span> head;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">100</span>;         <span class="comment">//静态链表大小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>            <span class="comment">//静态链表结点</span></span><br><span class="line">  ListData data; <span class="comment">// 数据域  </span></span><br><span class="line">  <span class="keyword">int</span> link; <span class="comment">// 游标域 书上是“cur”</span></span><br><span class="line">&#125; SNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>                 <span class="comment">//静态链表</span></span><br><span class="line">  SNode Nodes[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> newptr;                  <span class="comment">//当前可分配空间首地址</span></span><br><span class="line">&#125; SLinkList;</span><br></pre></td></tr></table></figure>

<p>1、InitList(&amp;Slink)；初始化带头结点静态链表Slink；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SLinkList &amp;Space，<span class="keyword">int</span> &amp;Slink)</span></span>&#123; </span><br><span class="line">                 <span class="comment">//初始化带头结点的静态链表Slink为空表</span></span><br><span class="line"><span class="keyword">if</span> (Space.newptr!=<span class="number">-1</span>)  </span><br><span class="line">&#123;Slink =Space.newptr;                  <span class="comment">//创建头结点 </span></span><br><span class="line"> Space.newptr= Space.Nodes[Space.newptr].link；&#125;</span><br><span class="line">                                  <span class="comment">//删除备用链表第一结点</span></span><br><span class="line"> Space.Nodes[Slink].link=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>2、DestroyList(&amp;Slink) 销毁带头节点静态链表Slink</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SLinkList &amp;Space，<span class="keyword">int</span> &amp;Slink)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//删去带头节点静态链表Slink所有结点，包括头结点</span></span><br><span class="line"> q =Slink；                  <span class="comment">//只需将销毁链插入到备用链表</span></span><br><span class="line"> <span class="keyword">while</span> (Space.Nodes[Slink].link!=<span class="number">-1</span>)      <span class="comment">//找链尾</span></span><br><span class="line"> Slink=Space.Nodes[Slink].link;</span><br><span class="line"> Space.Nodes[Slink].link=Space.newptr;<span class="comment">//链接链尾与备用链表表头</span></span><br><span class="line"> Space.newptr=q；        <span class="comment">//设置备用链表头指针为销毁链头指针</span></span><br><span class="line"> Slink=<span class="number">-1</span>；</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 3、 ClearList(Slink) 清空带头节点静态链表Slink</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SLinkList &amp;Space，<span class="keyword">int</span> Slink)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清空带头节点静态链表Slink，保留头结点</span></span><br><span class="line"> p = Space.Nodes[Slink].link；<span class="comment">//将清空链插入到备用链表</span></span><br><span class="line"> <span class="keyword">while</span> (Space.Nodes[p].link!=<span class="number">-1</span>)         <span class="comment">//找链尾</span></span><br><span class="line">   p=Space.Nodes[p].link;</span><br><span class="line"> Space.Nodes[p].link=Space.newptr；</span><br><span class="line">                    <span class="comment">//把链尾和备用链表表头相连</span></span><br><span class="line"> Space.newptr= Space.Nodes[Slink].link；         </span><br><span class="line">                           <span class="comment">//设置备用链表头指针</span></span><br><span class="line"> Space.Nodes[Slink].link=<span class="number">-1</span>;    <span class="comment">//设置空链表尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 4、 ListEmpty(Slink) 判断带头结点静态链表Slink是否为空，若为空返回1,否则返回0； </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListEmpty</span><span class="params">(SLinkList &amp;Space，<span class="keyword">int</span> Slink)</span> </span></span><br><span class="line"><span class="function"></span>&#123;          <span class="comment">//若带头结点静态链表Slink为空返回1,否则返回0</span></span><br><span class="line">    <span class="keyword">return</span> (Space.Nodes[Slink].link==<span class="number">-1</span>) ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、 ListLength (Slink) 求带头结点静态链表Slink的长度 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(SLinkList &amp;Space，<span class="keyword">int</span> Slink)</span> </span>&#123;</span><br><span class="line">             <span class="comment">//函数返回带头结点静态链表Slink长度</span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>; </span><br><span class="line">q=Slink；</span><br><span class="line"><span class="keyword">while</span> (Space.Nodes[q].link!=<span class="number">-1</span>)      <span class="comment">//在链上移动，计数</span></span><br><span class="line">  &#123;q=Space.Nodes[q].link; count++; &#125;</span><br><span class="line"><span class="keyword">return</span> count;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 6、 GetElem (Slink, i ) 函数值为带头结点静态链表Slink中第 i个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListData <span class="title">GetElem</span><span class="params">(SLinkList &amp;Space, <span class="keyword">int</span> Slink, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数返回带头结点静态链表Slink第i个元素值，不存在返回NULL</span></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>; q=Slink；</span><br><span class="line"><span class="keyword">while</span> (q!=<span class="number">-1</span>&amp;&amp; j&lt;i)      <span class="comment">//找第i个元素</span></span><br><span class="line"> &#123;q=Space.Nodes[q].link; j++; &#125;</span><br><span class="line"><span class="keyword">if</span> (p=<span class="number">-1</span>||j&gt;i) <span class="keyword">return</span> <span class="literal">NULL</span>;              <span class="comment">//第i个元素不存在</span></span><br><span class="line"><span class="keyword">return</span> Space.Nodes[q].data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7-1、LocateElem(SLink, x )  查找x在带头结点静态链表SLink中位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SLinkList &amp;Space, <span class="keyword">int</span> Slink, ListData x )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//在带头结点静态链表Slink中找值为x结点，找到返回x位置，否则返回-1</span></span><br><span class="line"> q=Space.Nodes[Slink].link；</span><br><span class="line"> <span class="keyword">while</span> (q!=<span class="number">-1</span>&amp;&amp; Space.Nodes[q].data!=x)      <span class="comment">//找X</span></span><br><span class="line">   q=Space.Nodes[q].link;</span><br><span class="line"> <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7-2、 IsIn(SLink, x ) 若x在带头结点静态链表Slink函数返回1否则返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsIn</span><span class="params">(SLinkList &amp;Space, <span class="keyword">int</span> Slink, ListData x )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//在带头结点静态链表Slink中找值为x结点，找到返回1否则返回0</span></span><br><span class="line"> q=Space.Nodes[Slink].link；</span><br><span class="line"> <span class="keyword">while</span> (q!=<span class="number">-1</span>&amp;&amp; Space.Nodes[q].data!=x)      <span class="comment">//找X</span></span><br><span class="line">   q=Space.Nodes[q].link;</span><br><span class="line"> <span class="keyword">return</span> !(q=<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、 NextElem (Slink, x ) 在带头结点静态链表Slink中求x的直接后继</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">NextElem</span><span class="params">(SLinkList &amp;Space, <span class="keyword">int</span> Slink, ListData x )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">////函数返回带头结点静态链表Slink中x的直接后继地址，没有返回-1</span></span><br><span class="line"> q=Space.Nodes[Slink].link；</span><br><span class="line"> <span class="keyword">while</span> (q!=<span class="number">-1</span>&amp;&amp; Space.Nodes[q].data!=x)      <span class="comment">//找X</span></span><br><span class="line">   q=Space.Nodes[q].link;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (q=<span class="number">-1</span> || Space.Nodes[q].link=<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//没有直接后继</span></span><br><span class="line"><span class="keyword">return</span> Space.Nodes[q].link;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9、PriorElem (Slink, x ) 在带头结点静态链表Slink中求x的直接前驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">NextElem</span><span class="params">(SLinkList &amp;Space, <span class="keyword">int</span> Slink, ListData x )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">////函数返回带头结点静态链表Slink中x的直接前驱地址，没有返回-1</span></span><br><span class="line"> q=Space.Nodes[Slink].link；</span><br><span class="line"> <span class="keyword">while</span> (q!=<span class="number">-1</span>&amp;&amp;Space.Nodes[q].link!=<span class="number">-1</span> &amp;&amp;Space.Nodes[Space.Nodes[q].link].data!=x)    <span class="comment">//找X</span></span><br><span class="line">   q=Space.Nodes[q].link;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">if</span> (q=<span class="number">-1</span> || Space.Nodes[q].link=<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//没有直接前驱</span></span><br><span class="line"><span class="keyword">return</span> q;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10、 ListInsert (Slink, i, x)  在带头节点静态链表Slink的第 i 个元素结点前插入 x</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">( SLinkList &amp;Space, <span class="keyword">int</span> Slink, <span class="keyword">int</span> i, ListData x )</span> </span>&#123;</span><br><span class="line">          <span class="comment">//在带头节点的静态链表Slink第 i 个结点前插入x，插入成功返回1否则返回0</span></span><br><span class="line"> <span class="keyword">int</span> j=<span class="number">0</span>; q=Slink；</span><br><span class="line"> <span class="keyword">while</span> (q!=<span class="number">-1</span>&amp;&amp; j&lt;i<span class="number">-1</span>)            <span class="comment">//找第i-1个元素</span></span><br><span class="line">   &#123;q=Space.Nodes[q].link; j++; &#125;</span><br><span class="line"> <span class="keyword">if</span> (q==<span class="number">-1</span>|| i&lt;<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;                            <span class="comment">//插入位置 i 错误</span></span><br><span class="line"> <span class="keyword">if</span> (Space.newptr!=<span class="number">-1</span>) &#123;p=Space.newptr;                    <span class="comment">//分配结点</span></span><br><span class="line">                     Space.newptr = Space.Nodes[Space.newptr].link;&#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>                             <span class="comment">//备用链表空</span></span><br><span class="line"> Space.Nodes[p].data = x;</span><br><span class="line"> Space.Nodes[p].link = Space.Nodes[q].link;</span><br><span class="line"> Space.Nodes[q].link = p;                       <span class="comment">//插入</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11、 ListDelete (Slink, i ) 删除带头节点静态链表Slink的第 i 个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">( SLinkList &amp;Space, <span class="keyword">int</span> Slink, <span class="keyword">int</span> i )</span> </span>&#123;</span><br><span class="line">  <span class="comment">//在带头结点的静态链表Slink删除第 i 个元素结点，删除成功返回1否则返回0</span></span><br><span class="line"> <span class="keyword">int</span> p =Slink;</span><br><span class="line"> <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (p!=<span class="number">-1</span>&amp;&amp;j++&lt;i<span class="number">-1</span>) p=Space.Nodes[p].link;</span><br><span class="line"> <span class="keyword">if</span> ( p ==<span class="number">-1</span>||Space.Nodes[p].link==<span class="number">-1</span> ||i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//找不到结点</span></span><br><span class="line"> <span class="keyword">int</span> q = Space.Nodes[p].link;           <span class="comment">//准备删除第 i个元素结点</span></span><br><span class="line"> Space.Nodes[p].link = Space.Nodes[q].link;</span><br><span class="line"> Space.Nodes[q].link = Space.newptr;   <span class="comment">//释放，链入备用链表表头</span></span><br><span class="line"> Space.newptr = q;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><ul>
<li>特点:最后一个结点的 link 指针不为NULL，而是指向第一个结点。只要已知表中某一结点的地址，就可搜寻所有结点的地址。</li>
<li>存储结构:链式存储结构</li>
<li> 单循环链表：在单链表中，将终端结点的指针域NULL改为指向表头结点的或开始结点，就得到了单链形式的循环链表，并简单称为单循环链表。    </li>
<li>为了使空表和非空表的处理一致，循环链表中也可设置一个头结点。这样，空循环链表仅有一个自成循环的头结点表示。</li>
</ul>
<h3 id="第二章作业三"><a href="#第二章作业三" class="headerlink" title="第二章作业三"></a>第二章作业三</h3><ul>
<li><p>1、 设计一个算法，将链表中所有结点的链接方向“原地”逆转，即要求仅利用原表的存储空间（也就是说，算法的空间复杂都为O(1)）。</p>
<p>所有源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> listData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  listData data;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;ListNode;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ListNode *LinkList;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(LinkList &amp;first)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  first =<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;first,listData x,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  LinkList p,newnode;</span><br><span class="line"></span><br><span class="line">  newnode=(ListNode* )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line"></span><br><span class="line">  newnode-&gt;data=x;</span><br><span class="line"></span><br><span class="line">  p= first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">​    newnode-&gt;next=p;</span><br><span class="line"></span><br><span class="line">​    first=newnode;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!p||i&lt;<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">  k=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(p&amp;&amp;k&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line"></span><br><span class="line">​    p=p-&gt;next;</span><br><span class="line"></span><br><span class="line">​    k++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p)&#123;</span><br><span class="line"></span><br><span class="line">  newnode-&gt;next=p-&gt;next;</span><br><span class="line"></span><br><span class="line">  p-&gt;next=newnode;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">free</span>(newnode);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Reverse</span><span class="params">(LinkList &amp;first)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  LinkList p,q,x;</span><br><span class="line"></span><br><span class="line">  p=first;</span><br><span class="line"></span><br><span class="line">  q=first;</span><br><span class="line"></span><br><span class="line">  x=first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(q)&#123;</span><br><span class="line"></span><br><span class="line">​    q=q-&gt;next;</span><br><span class="line"></span><br><span class="line">​    i++;  <span class="comment">//计算链表长度</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  q=first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span>(x-&gt;next)&#123;</span><br><span class="line"></span><br><span class="line">​      x=x-&gt;next; <span class="comment">//指向当前原顺序链表最后一个节点</span></span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(j==i)&#123;</span><br><span class="line"></span><br><span class="line">​      q=x;  <span class="comment">//用q指针记住原链表最后一个节点（翻转后的第一个节点）</span></span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">​      p=first; <span class="comment">//原链表表按原顺序只剩两个节点时候p指向第一个节点</span></span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">while</span>(p-&gt;next-&gt;next)&#123;</span><br><span class="line"></span><br><span class="line">​        p=p-&gt;next; <span class="comment">//指向x指向节点的前一个节点</span></span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  x-&gt;next=p; <span class="comment">//翻转过程 后一个节点的next指向前一个节点</span></span><br><span class="line"></span><br><span class="line">  p-&gt;next=<span class="literal">NULL</span>; <span class="comment">//把前一个节点的next先断掉 原链表长度-1</span></span><br><span class="line"></span><br><span class="line">  x=first; <span class="comment">//x，q回到初始节点重新遍历</span></span><br><span class="line"></span><br><span class="line">  p=first;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  first=q;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ShowList</span><span class="params">(LinkList first)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  LinkList p=first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  i=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(p)&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">&quot;a[%d]=%d\n&quot;</span>,i,p-&gt;data);</span><br><span class="line"></span><br><span class="line">​    p=p-&gt;next;</span><br><span class="line"></span><br><span class="line">​    i++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  LinkList L;</span><br><span class="line"></span><br><span class="line">  InitList(L);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">​    ListInsert(L, i*<span class="number">10</span>, i);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ShowList(L);</span><br><span class="line"></span><br><span class="line">  Reverse(L);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;翻转后\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ShowList(L);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>实现结果 完成翻转</p>
<p>​                               </p>
<p>2、定义静态链表的存储结构；写出不带头结点静态链表的插入和删除算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  ElemType data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> cur;</span><br><span class="line"></span><br><span class="line">&#125; StaticLinkList[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//在备用表中找到并返回第一个元素的下标，并改变数组[0]的cur</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SL</span><span class="params">(StaticLinkList space)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = space[<span class="number">0</span>].cur;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (space[<span class="number">0</span>]. cur)</span><br><span class="line"></span><br><span class="line">​    space[<span class="number">0</span>]. cur = space[i].cur;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取使用链表的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i=L[MAXSIZE<span class="number">-1</span>].cur;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(i)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    i=L[i].cur;</span><br><span class="line"></span><br><span class="line">​    j++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">ListInsert</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i, ElemType x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> j, k, l;</span><br><span class="line"></span><br><span class="line">  k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否超范围</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回备用表第一个元素的下标</span></span><br><span class="line"></span><br><span class="line">  j = Malloc_SL(L);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (j)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    L[j].data = x;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//找到i前面的元素下标k</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span>(l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++)</span><br><span class="line"></span><br><span class="line">​      k = L[k].cur;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//j继承k的cur</span></span><br><span class="line"></span><br><span class="line">​    L[j].cur = L[k].cur;</span><br><span class="line"></span><br><span class="line">​    L[k].cur = j;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SL</span><span class="params">(StaticLinkList space, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  space[i].cur = space[<span class="number">0</span>].cur;</span><br><span class="line"></span><br><span class="line">  space[<span class="number">0</span>].cur = i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">ListDelete</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> j, k;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L))</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line"></span><br><span class="line">​    k = L[k].cur;</span><br><span class="line"></span><br><span class="line">  j = L[k].cur;</span><br><span class="line"></span><br><span class="line">  L[k].cur = L[j].cur;</span><br><span class="line"></span><br><span class="line">  Free_SL(L, j);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、已知一个带有表头结点的单链表，结点结构为(data，ink)，假设该链表只给出了头指针first。在不改变链表的前提下，请设计一个尽可能高效的算法，査找链表中倒数第k个位置上的结点(k为正整数)。若查找成功，算法输出该结点的data域的值，并返回1。（1）描述算法基本设计思想；（2）描述算法实现步骤；（3）采用程序设计语言描述算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchK</span><span class="params">(LinkList &amp;<span class="built_in">list</span>,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查找链表list倒数第k个结点，并输出该结点data域的值</span></span><br><span class="line"></span><br><span class="line">  LinkList p,q;</span><br><span class="line"></span><br><span class="line">  p=<span class="built_in">list</span>-&gt;next;</span><br><span class="line"></span><br><span class="line">  q=<span class="built_in">list</span>-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//计数器初始化为0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(p)&#123;<span class="comment">//指针p依次遍历链表直至最后一个结点</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(count&lt;k)&#123;</span><br><span class="line"></span><br><span class="line">​      count++;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">​      q=q-&gt;next;&#125;</span><br><span class="line"></span><br><span class="line">​      p=p-&gt;next;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(count&lt;k)&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> q-&gt;data;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ul>
<li>​     和单链表类似，双链表一般也是由头指针唯一确定的，增加头指针也能使双链表上的某些运算变得方便，将头结点和尾结点链接起来也能构成循环链表，并称之为双向链表。</li>
<li>设指针p指向某一结点，则双向链表结构的对称性可用下式描述：</li>
<li>(p—&gt;prior)—&gt;next=p=(p—&gt;next)—&gt;prior</li>
<li> 即结点<em>p的存储位置既存放在其前趋结点</em>(p—&gt;prior)的直接后继指针域中，也存放 在它的后继结点*(p—&gt;next)的直接前趋指针域中。</li>
<li>双向链表优点：访问、插入、删除更方便、速度更快。</li>
<li>不足：以空间换时间</li>
</ul>
<h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ListData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dnode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  ListData data;             </span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dnode</span> * <span class="title">prior</span>, * <span class="title">next</span>;</span>   </span><br><span class="line"></span><br><span class="line">&#125; DblNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> DblNode * DblList;     </span><br></pre></td></tr></table></figure>

<p>初始化双向循环链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">( DblList  &amp;first )</span> </span>&#123;</span><br><span class="line">                  <span class="comment">//初始化带头结点的双向循环链表first</span></span><br><span class="line">  first = ( DblNode*) <span class="built_in">malloc</span> ( <span class="keyword">sizeof</span> ( DblNode ) );</span><br><span class="line">  <span class="keyword">if</span> ( !first )</span><br><span class="line">    &#123; print ( “存储分配错!\n” ); <span class="built_in">exit</span> (<span class="number">1</span>); &#125;</span><br><span class="line">  first→prior = first→next = first;</span><br><span class="line">                       <span class="comment">//表头结点的链指针指向自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求双向循环链表长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span> <span class="params">( DblList first )</span> </span>&#123;</span><br><span class="line">             <span class="comment">//计算带头结点的双向循环链表的长度</span></span><br><span class="line">  DblNode * p = first→next;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( p != first ) </span><br><span class="line">     &#123; p = p→next; count++; &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span> <span class="params">( DblList first, <span class="keyword">int</span> i, ListData x )</span> </span>&#123;</span><br><span class="line">   <span class="comment">//在带头结点的双向循环链表first的第i个结点前插入x</span></span><br><span class="line">   DblNode * p = LocateElem ( first, i<span class="number">-1</span> );  </span><br><span class="line">                         <span class="comment">//指针定位于插入位置</span></span><br><span class="line">   <span class="keyword">if</span> ( p == first &amp;&amp; i != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   DblNode * q = ( DblNode * ) <span class="built_in">malloc</span></span><br><span class="line">      ( <span class="keyword">sizeof</span> ( DblNode ) );          <span class="comment">//分配结点</span></span><br><span class="line">   q→data = x;</span><br><span class="line">   q→prior = p;  q→next = p→next;</span><br><span class="line">   p→next = q; q→next→prior = q; </span><br><span class="line">                                 <span class="comment">//链入新结点</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">( DblList first, <span class="keyword">int</span> i )</span> </span>&#123;</span><br><span class="line">           <span class="comment">//在带头结点的双向循环链表first的删除第i个结点</span></span><br><span class="line">   DblNode * p = LocateElme( first, i );  </span><br><span class="line">                         <span class="comment">//指针定位于删除结点位置</span></span><br><span class="line">   <span class="keyword">if</span> ( p == first ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   p→next→prior = p→prior;</span><br><span class="line">   p→prior→next = p→next;       <span class="comment">//删除结点 p</span></span><br><span class="line">   <span class="built_in">free</span> ( p );                      <span class="comment">//释放</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二章作业四"><a href="#第二章作业四" class="headerlink" title="第二章作业四"></a>第二章作业四</h3><p>1、 分别在带头结点的双链表中的第一个值为x的结点之前、之后插入元素值为y的结点，分别编写各自的算法。</p>
<p>之前插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">y_insert</span><span class="params">(Dlinklist **head, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  linklist L = (*head) -&gt; next, p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(L &amp;&amp; L -&gt; data != x) </span><br><span class="line"></span><br><span class="line">​    L = L -&gt; next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!L)     </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    p = (linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Dlinklist));     </span><br><span class="line"></span><br><span class="line">​    p -&gt; data = y;       </span><br><span class="line"></span><br><span class="line">​    L -&gt; prior -&gt; next = p;   </span><br><span class="line"></span><br><span class="line">​    p -&gt; prior = L -&gt; prior;</span><br><span class="line"></span><br><span class="line">​    L -&gt; prior = p;</span><br><span class="line"></span><br><span class="line">​    p -&gt; next = L;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">y_afterinsert</span><span class="params">(Dlinklist **head, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  linklist L = (*head) -&gt; next, p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(L &amp;&amp; L -&gt; data != x) </span><br><span class="line"></span><br><span class="line">​    L = L -&gt; next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!L)     </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    p-&gt;next = L-&gt;next;</span><br><span class="line"></span><br><span class="line">​    p-&gt;prior = L;</span><br><span class="line"></span><br><span class="line">​    L-&gt;next-&gt;prior = p;</span><br><span class="line"></span><br><span class="line">​    L-&gt;next = p;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、有一个双链表L，其中有n(n&gt;=1)个值不相同的数据节点，设计一个算法删除最大值的结点。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(DLinkList &amp;dlLink, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  DLinkList p = dlLink;</span><br><span class="line"></span><br><span class="line">  DLinkList deleteNode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    max = p-&gt;data;</span><br><span class="line"></span><br><span class="line">​    p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (p-&gt;data &gt; max)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      max = p-&gt;data;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p = dlLink;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (p-&gt;data == max)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  deleteNode = p-&gt;next;</span><br><span class="line"></span><br><span class="line">  deleteNode-&gt;next-&gt;prev = p;</span><br><span class="line"></span><br><span class="line">  p-&gt;next = deleteNode-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(deleteNode);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三章-栈与递归"><a href="#第三章-栈与递归" class="headerlink" title="第三章 栈与递归"></a>第三章 栈与递归</h2><ul>
<li><h2 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h2></li>
<li><h2 id="若一个对象部分地包含它自己-或用它自己给自己定义-则称这个对象是递归的；若一个过程直接地或间接地调用自己-则称这个过程是递归的过程。"><a href="#若一个对象部分地包含它自己-或用它自己给自己定义-则称这个对象是递归的；若一个过程直接地或间接地调用自己-则称这个过程是递归的过程。" class="headerlink" title="若一个对象部分地包含它自己, 或用它自己给自己定义, 则称这个对象是递归的；若一个过程直接地或间接地调用自己, 则称这个过程是递归的过程。"></a>若一个对象部分地包含它自己, 或用它自己给自己定义, 则称这个对象是递归的；若一个过程直接地或间接地调用自己, 则称这个过程是递归的过程。</h2></li>
<li><p>n<strong>以下三种情况常常用到递归方法</strong></p>
<p>Ø<strong>递归定义的数学函数</strong></p>
<p>Ø<strong>具有递归特性的数据结构</strong></p>
<p>Ø<strong>可递归求解的问题</strong></p>
</li>
<li><p>分治法</p>
<ul>
<li><p>对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解</p>
</li>
<li><p><strong>必备的三个条件</strong></p>
<ul>
<li><p>1、能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是变化有规律的</p>
<p>2、可以通过上述转化而使问题简化</p>
<p>3、必须有一个明确的递归出口，或称递归的边界</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>递归的优缺点</p>
<ul>
<li>优点：结构清晰，程序易读</li>
<li>缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。</li>
</ul>
</li>
</ul>
<ol>
<li>栈</li>
</ol>
<ul>
<li>§定义:是限定仅在表尾进行插入或删除操作的线性表。</li>
<li>§允许插入和删除的一端</li>
<li> 称为栈顶(top)，另一端</li>
<li> 称为栈底(bottom)</li>
<li>§特点:后进先出(先进后出)</li>
</ul>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>§顺序栈：栈的顺序存储结构，利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，</p>
<p> 指针top指向栈顶元素在顺序栈中的下一个位置，</p>
<p> 指针base为栈底指针，指向栈底的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100；<span class="comment">//存储空间初始分配量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT 10；<span class="comment">//存储空间分配的增量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">//顺序栈定义</span></span><br><span class="line"> SElemType *base; <span class="comment">//栈底指针 </span></span><br><span class="line"> SElemType *top;  <span class="comment">//栈顶指针 </span></span><br><span class="line"> <span class="keyword">int</span> stacksize； <span class="comment">//当前已分配的存储空间</span></span><br><span class="line">&#125; SqStack；</span><br></pre></td></tr></table></figure>

<p>•初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span> <span class="params">( SqStack &amp;S)</span> </span>&#123;  <span class="comment">//建空栈</span></span><br><span class="line"></span><br><span class="line"> S.base =( SElemType *) <span class="built_in">malloc</span>(STACK_INIT_SIZE *  <span class="keyword">sizeof</span>(SElemType));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!S.base) <span class="built_in">exit</span>(OVERFLOW);  <span class="comment">//存储分配失败</span></span><br><span class="line"></span><br><span class="line"> S.top = S.base ; </span><br><span class="line"></span><br><span class="line"> S.Stacksize = STACK_INIT_SIZE ;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>§判栈空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span> <span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( S.top == S.base ) <span class="keyword">return</span> TRUE; <span class="comment">//栈空</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> FALSE; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>§判栈满</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackFull</span> <span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>( S.top - S.base &gt;= S.StackSize )    <span class="comment">//栈满</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TRUE; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求栈的长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">( SqStack S )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> S.top – S.base;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清空顺序栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">( SqStack S )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>( S.base ) S.top = S.base;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>销毁顺序栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">( SqStack &amp;S )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>( S.base )</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">delete</span> S.base ;</span><br><span class="line"></span><br><span class="line"> S.stacksize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> S.base = S.top = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§入栈(进栈)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span> <span class="params">(SqStack &amp;S, SElemType e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素e为新的栈顶元素</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( StackFull (S) )&#123; <span class="comment">//栈满，追加存储空间</span></span><br><span class="line"></span><br><span class="line"> S.base = ( SElemType *)<span class="built_in">malloc</span>(S.base ,</span><br><span class="line"></span><br><span class="line">   (S.stacksize + STACKINCREMENT) *    <span class="keyword">sizeof</span>(SElemType));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(! S.base) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">  S.top = S.base + S.stacksize;</span><br><span class="line"></span><br><span class="line"> S.stacksize += STACKINCREMENT; </span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> *(S.top++) = e;</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺序栈出栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">( SqStack &amp;S, SElemType &amp;e)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//若栈空返回ERROR, 否则删除栈顶元素，用e返回其值.</span></span><br><span class="line">	<span class="keyword">if</span>( S.top == S.base ) <span class="comment">// 栈空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR; 	</span><br><span class="line">	e＝ *--S.top;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取顺序栈栈顶元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">( SqStack S, SElemType &amp;e)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//若栈空返回ERROR, 否则栈顶元素读到e并返回OK</span></span><br><span class="line">	<span class="keyword">if</span>( S.top == S.base )	 <span class="keyword">return</span> ERROR; 	<span class="comment">// 栈空</span></span><br><span class="line">	e = *( S.top – <span class="number">1</span> );</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态顺序栈"><a href="#静态顺序栈" class="headerlink" title="静态顺序栈"></a>静态顺序栈</h3><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    SElemType data;	       <span class="comment">//结点	</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>	       <span class="comment">//链指针</span></span><br><span class="line">&#125; StackNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    StackNode *top;           <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; LinkStack;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol>
<li><p>队列</p>
<ol>
<li>基本概念</li>
<li>定义:只允许在表的一端进行插入，而在另一端删除元素的线性表。也是一种运算受限的线性表。</li>
<li>  在队列中，允许插入的一端叫队尾(rear)，</li>
<li>允许删除的一端称为队头(front)。</li>
<li>先进先出</li>
</ol>
</li>
<li><p>队列、栈和线性表的区别与联系</p>
<ol>
<li><p>栈和队列都是线性表，都是限制了插入删除点的线性表（或者说是控制了访问点的线性表）</p>
<p>区别：栈只允许在一端进行插入或删除操作的线性表，其最大的特点是“后进后出”；队列是只允许在一端进行插入，另一端进行删除操作的线性表，其最大的特点是“先进后出”；一般的线性表允许在表中任意位置进行插入或删除操作。</p>
<p>联系（共同点）：n个（同类）数据元素的有限序列称为线性表。线性表的特点是数据元素之间存在“一对一”的关系，栈和队列都是操作受限制的线性表，他们和线性表一样，数据元素之间都存在“一对一”的关系。栈和队列都是只能在线性表的端点插入和删除。</p>
</li>
</ol>
</li>
</ol>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100   <span class="comment">//最大长度</span></span></span><br><span class="line"></span><br><span class="line">Typedef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"></span><br><span class="line"> QElemType *data; <span class="comment">//初始化的动态分配存储空间</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> front; <span class="comment">//头指针 </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> rear; <span class="comment">//尾指针</span></span><br><span class="line"></span><br><span class="line">&#125; SqQueue</span><br></pre></td></tr></table></figure>

<p>§初始化队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span> <span class="params">( SqQueue &amp;Q )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造空队列</span></span><br><span class="line"></span><br><span class="line"> Q.data=(QueueData *)<span class="built_in">malloc</span>(MAXSIZE  *<span class="keyword">sizeof</span>(QueueData));</span><br><span class="line"></span><br><span class="line"> If(! Q.data)  <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line"> Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> ok</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求循环队列的长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span> <span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (Q.rear-Q.front+Maxsize)%Maxsize;               </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>1） Q.rear&gt;=Q.front, 那么Q.rear-Q.front。</p>
<p>2） Q.rear &lt; Q.front, 那么Q.rear-Q.front+Maxsize</p>
<p>统一为： (Q.rear-Q.front+Maxsize)%Maxsize。</p>
<p>ü当Q.rear-Q.front为正数时，加上Maxsize就超过了最大空间数，取余后就正好是元素个数；</p>
<p>ü当Q.rear-Q.front为负数时，加上Maxsize就正好是元素个数，由于小于Maxsize，故取余运算对其没有影响。</p>
<p>所以， %Maxsize是为了防止Q.rear-Q.front为正数的情况，+Maxsize为了防止Q.rear-Q.front为负数的情况。</p>
<p>§判队空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span> <span class="params">( SqQueue &amp;Q )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Q.rear == Q.front;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§判队满</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueFull</span> <span class="params">( SqQueue &amp;Q )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (Q.rear+<span class="number">1</span>) % QueueSize == Q.front;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§入队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span> <span class="params">( SqQueue &amp;Q, QElemType e )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( QueueFull (Q) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  Q.data[Q.rear] = e;</span><br><span class="line">  Q.rear = ( Q.rear+<span class="number">1</span>) % MAXSIZE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§出队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span> <span class="params">( SqQueue &amp;Q, QElemType &amp;e )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( QueueEmpty (Q) ) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">  e = Q.data[Q.front]; </span><br><span class="line"></span><br><span class="line"> Q.front = ( Q.front+<span class="number">1</span>) % MAXSIZE;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§取队头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFront</span> <span class="params">( SqQueue &amp;Q, QElemtype &amp;e )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ( QueueEmpty (Q) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   e = Q.data[(Q.front+<span class="number">1</span>) % MAXSIZE];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h3><p>链式队列的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span> </span><br><span class="line"></span><br><span class="line">  QElemType   data;  <span class="comment">//队列结点数据</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span> <span class="comment">//结点链指针</span></span><br><span class="line"></span><br><span class="line">&#125; QNode, *QueuePtr;   <span class="comment">//链队数据结点类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  QueuePtr  front;   <span class="comment">//队头指针</span></span><br><span class="line"></span><br><span class="line">  QueuePtr  rear;   <span class="comment">//队尾指针</span></span><br><span class="line"></span><br><span class="line">&#125; LinkQueue;  <span class="comment">//链队结点类型</span></span><br></pre></td></tr></table></figure>

<p>§初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">Status <span class="title">InitQueue</span> <span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  Q.front=Q.rear=(QueuePtr) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode)); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">  Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>销毁链队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyQueue</span> <span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(Q.front)&#123;</span><br><span class="line"></span><br><span class="line">   Q.rear=Q.front-&gt;next;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(Q.front);</span><br><span class="line"></span><br><span class="line">   Q.front=Q.rear;  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§判断队空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span> <span class="params">( LinkQueue &amp;Q )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Q.front == <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//当Q.front==NULL且Q.rear=NULL时，链式队列为空</p>
<p>§取队头元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFront</span> <span class="params">( LinkQueue &amp;Q, QueueData &amp;e )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( QueueEmpty (Q) ) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">  e = Q.front-&gt;data; <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§入队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素e为Q的新的队尾结点</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(QueuePtr Q, QElemType e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  QueuePtr q = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!q) &#123;        <span class="comment">//存储分配失败</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  q-&gt;data = e;</span><br><span class="line"></span><br><span class="line">  q-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">  Q-&gt;rear-&gt;next = q; <span class="comment">//先使rear指向结点的next指向新节点q</span></span><br><span class="line"></span><br><span class="line">  Q-&gt;rear = q;     <span class="comment">//再使尾指针指向q</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§出队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span> <span class="params">( LinkQueue &amp;Q, QueueData &amp;e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删去队头结点，并返回队头元素的值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( QueueEmpty (Q) ) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//判队空</span></span><br><span class="line"></span><br><span class="line">  QueueNode *p = Q.front; </span><br><span class="line"></span><br><span class="line">  e = p-&gt;data; <span class="comment">//保存队头的值</span></span><br><span class="line"></span><br><span class="line">  Q.front= Q.front-&gt;next;  <span class="comment">//新队头</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (Q.rear == p)   Q.rear = Q.front;  <span class="comment">//对队尾指针重新赋值（指向头 结点）</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">free</span> (p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环队列与链队列的比较</p>
<p>从时间上考虑，循环队列和链队列的基本操作都是O(1),不过循环队列是事先已申请好空间，使用期间不会释放。而对于链队列，每次申请和释放结点也会存在一些时间开销。如果入队和出队频繁，两者还是有细微差异的。<br> 　从空间来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但是是可以接受的。所以从空间上说，链队列更加灵活。<br> 　总的来说，在可以确定链队列最大长度的情况下，建议使用循环队列。如果无法预估队列的长度，则使用链队列。</p>
<p>Ø循环队列要事先申请好空间，整个过程都不能释放，而且要有固定的长度，如果长度事先无法估计，这种方式显然不够灵活；</p>
<p>Ø所以就引入了链式存储队列，其实就是线性表的单链表，只是它只能对尾进，队头出。并且规定队头指针指向链队列的头结点，对尾指针指向终端节点，当队列为空时，front和rear都指向头结点。入队操作，就是在链表尾部插入结点；出队操作就是头结点的后继结点出队，然后将头结点的后继后移。如果最后除了头结点外，只剩一个元素了，就把rear也指向头结点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" data-id="ckomi7m4w000bo6514nq745kj" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2021/05/10/React/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/13/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/05/12/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/05/10/%E5%AD%A6%E4%B9%A0%E3%80%81%E6%8F%92%E4%BB%B6%E7%BD%91%E5%9D%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/05/10/leetcode%E5%88%B7%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/05/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>