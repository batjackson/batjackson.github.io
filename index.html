<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/13/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-05-13T05:47:08.485Z" itemprop="datePublished">2021-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/13/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/13/hello-world/" data-id="ckomi7m4f0002o6519qfwhzan" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/12/README/" class="article-date">
  <time class="dt-published" datetime="2021-05-12T04:32:20.946Z" itemprop="datePublished">2021-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="webtree"><a href="#webtree" class="headerlink" title="webtree"></a>webtree</h1><p>我的前端技能树 持续更新 记录成长</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/12/README/" data-id="ckomi7m460000o651h6ejd7c2" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-学习、插件网址" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/%E5%AD%A6%E4%B9%A0%E3%80%81%E6%8F%92%E4%BB%B6%E7%BD%91%E5%9D%80/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T18:15:48.101Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习、插件网址"><a href="#学习、插件网址" class="headerlink" title="学习、插件网址"></a>学习、插件网址</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/%E5%AD%A6%E4%B9%A0%E3%80%81%E6%8F%92%E4%BB%B6%E7%BD%91%E5%9D%80/" data-id="ckomi7m4g0004o651aer6fkn0" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode刷题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/leetcode%E5%88%B7%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T18:15:27.409Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcode刷题"><a href="#leetcode刷题" class="headerlink" title="leetcode刷题"></a>leetcode刷题</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/leetcode%E5%88%B7%E9%A2%98/" data-id="ckomi7m4h0005o6514gjr4e2g" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法设计与分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T18:15:17.478Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/" data-id="ckomi7m4p0007o651b6egb6q8" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T18:15:05.482Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/" data-id="ckomi7m4i0006o651emxfdbcx" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构与算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T18:14:57.201Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p>[TOC]</p>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="一、数据结构定义"><a href="#一、数据结构定义" class="headerlink" title="一、数据结构定义"></a>一、数据结构定义</h3><ol>
<li><h4 id="计算机解决问题的过程"><a href="#计算机解决问题的过程" class="headerlink" title="计算机解决问题的过程"></a>计算机解决问题的过程</h4><ol>
<li><strong>建立模型</strong></li>
<li><strong>构造求解算法</strong></li>
<li><strong>选择存储结构</strong></li>
<li><strong>编写程序</strong></li>
<li><strong>测试</strong></li>
</ol>
</li>
<li><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol>
<li>五类基本算法<ol>
<li><strong>贪婪算法</strong></li>
<li><strong>分而治之法</strong></li>
<li><strong>动态规划</strong></li>
<li><strong>回溯法</strong></li>
<li><strong>分支定界</strong></li>
</ol>
</li>
<li>其他高级算法<ol>
<li>线性规划</li>
<li>整数规划</li>
<li>遗传算法</li>
<li>模拟退火等</li>
</ol>
</li>
<li>非数值基础算法<ol>
<li>穷举法</li>
<li>贪心法（Huffman树，以最小代价生成树的Prim算法和Kruskal算法</li>
<li>分治法（递归法）</li>
<li>回溯法（深度优先、八皇后）</li>
<li>分支定界法（广度优先）</li>
<li>动态规划法（最佳二叉排序树）</li>
<li>å-ß裁剪和分支界限法</li>
<li>并行算法</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="数据结构研究对象"><a href="#数据结构研究对象" class="headerlink" title="数据结构研究对象"></a>数据结构研究对象</h4><ol>
<li>逻辑结构<ol>
<li>反映数据元素间的逻辑关系<ol>
<li><strong>线性结构</strong></li>
<li><strong>树结构</strong></li>
<li><strong>图结构</strong></li>
</ol>
</li>
</ol>
</li>
<li>存储结构<ol>
<li>反映数据元素及其关系在计算机存储器内的存储安排<ol>
<li><strong>顺序存储</strong></li>
<li><strong>链式存储</strong></li>
<li><strong>索引存储</strong></li>
<li><strong>散列存储</strong></li>
</ol>
</li>
</ol>
</li>
<li>运算对数据的最主要操作<ol>
<li><strong>增</strong></li>
<li><strong>删</strong></li>
<li><strong>改</strong></li>
<li><strong>查</strong></li>
</ol>
</li>
</ol>
</li>
<li><h4 id="不同数据结构操作集不同，但以下不可或缺"><a href="#不同数据结构操作集不同，但以下不可或缺" class="headerlink" title="不同数据结构操作集不同，但以下不可或缺"></a>不同数据结构操作集不同，但以下不可或缺</h4><ol>
<li>结构的生成</li>
<li>结构的销毁</li>
<li>在结构中查找满足规定条件的数据元素</li>
<li>在结构中插入新的数据元素</li>
<li>删除结构中已经存在的数据元素</li>
<li>遍历</li>
</ol>
</li>
<li><h4 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h4><ol>
<li>在计算机组织存储传递数据需讨论类和数据间的关系，以建立相应的数据结构，实现软件功能</li>
<li>数据结构描述现实世界实体的数据模型及其上的操作在计算机中的表示和实现</li>
<li>简单地说，<strong>数据结构是一门研究数值计算的程序设计问题中计算机操作对象及它们之间关系和操作等等的学科</strong><ol>
<li>数据结构是以某种特定的布局方式存储数据的容器</li>
<li>数据是计算机科学中最关键的载体而数据结构则可以将数据以某种形式存储</li>
<li>数据需要根据不同场景，按照特定的格式进行存储</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="二、基本概念和术语"><a href="#二、基本概念和术语" class="headerlink" title="二、基本概念和术语"></a>二、基本概念和术语</h3><ol>
<li><p>数据(Data)</p>
<ol>
<li><strong>被计算机识别和处理的符号集合</strong></li>
<li>包括<ol>
<li>数值性数据</li>
<li>非数值性数据</li>
</ol>
</li>
</ol>
</li>
<li><p>数据元素(data element)</p>
<ol>
<li><strong>数据基本单位</strong>。</li>
<li>一个数据元素由若干的数据项(data Item)组成</li>
<li>数据元素又称元素、结点、记录</li>
<li>例如：一个学生记录、树中期盼的一个格局（状态）、图中的一个顶点等</li>
</ol>
</li>
<li><p>数据项(data item)</p>
<ol>
<li><strong>是组成数据元素的</strong>、<strong>有独立含义的</strong>、<strong>不可分割的最小单位</strong></li>
<li>如：学生基本信息中的学号、姓名、性别等</li>
<li>数据项是具有独立含义的最小标识单位</li>
</ol>
</li>
<li><p>数据对象(data object)</p>
<ol>
<li><strong>具有相同性质的数据元素集合</strong><ol>
<li>举例<ol>
<li>整数数据对象<ol>
<li>N={0,+-1,+-2,…}</li>
</ol>
</li>
<li>字母字符数据对象<ol>
<li>C={‘A’,’B’,….’Z’}</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数据对象</p>
<ol>
<li>数据元素1<ol>
<li>数据项1</li>
</ol>
</li>
<li>数据元素2<ol>
<li>数据项1</li>
<li>数据项2</li>
</ol>
</li>
<li>数据元素3<ol>
<li>数据项1</li>
<li>数据项2</li>
<li>数据项3</li>
</ol>
</li>
</ol>
</li>
<li><p>数据结构(data structure)</p>
<ol>
<li>形式定义：<strong>数据结构是相互之间存在一种或者多种特定关系的数据元素的集合</strong></li>
<li>用二元组记为<ol>
<li>Data_Structure = {D,S}</li>
</ol>
</li>
<li>其中D为某一数据对象，S是该对象中所有数据乘员之间关系的有限集合</li>
<li>结构<ol>
<li>元素之间的关系称结构<ol>
<li>关系：描述的是数据元素之间的逻辑关系，称为数据的逻辑结构</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数据的逻辑结构</p>
<ol>
<li>从逻辑关系上描述数据，与数据存储无关</li>
<li>从具体问题抽象出来的数据模型</li>
<li>与数据元素本身的形式、内容无关</li>
<li>与数据元素的相对位置无关</li>
<li>数据的逻辑结构分类<ol>
<li>线性结构<ol>
<li>线性表</li>
</ol>
</li>
<li>非线性结构<ol>
<li>树</li>
<li>图（或网络）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数据的存储结构（物理结构）</p>
<ol>
<li>数据结构在计算机中的表示</li>
<li>数据的存储结构依赖于计算机语言<ol>
<li>顺序存储</li>
<li>链式存储</li>
<li>索引存储</li>
<li>散列存储</li>
</ol>
</li>
</ol>
</li>
<li><p>注意：</p>
<ol>
<li><p>数据的逻辑结构与存储结构密切相关</p>
<ol>
<li><p><strong>算法的设计取决于数据的逻辑结构</strong></p>
</li>
<li><p><strong>算法的实现取决于数据的物理结构</strong></p>
<blockquote>
<p>逻辑结构是数据元素之间的关系，存储结构是数据元素及其关系在计算机中的存储方式</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="三、抽象数据类型"><a href="#三、抽象数据类型" class="headerlink" title="三、抽象数据类型"></a>三、抽象数据类型</h3><ul>
<li><p>数据类型</p>
<ul>
<li>定义：一个值的集合和定义在这个值集上的一组操作的总称</li>
<li>C中基本的数据类型<ul>
<li>int char float double void</li>
</ul>
</li>
</ul>
</li>
<li><p>抽象数据类型</p>
<ul>
<li><p>是指一个数学模型及定义在此数学模型上的一组操作</p>
</li>
<li><p>数据结构+定义在此数据结构上的一组操作=抽象数据类型</p>
<ul>
<li><p>如:矩阵+（求转置、加、乘、求逆、求特征值）</p>
<p>构成一个矩阵的抽象数据类型</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据类型就是数据结构</p>
</li>
<li><p>数据类型是模版</p>
</li>
<li><p>基本数据类型可以看作是计算机中已实现的数据结构</p>
</li>
<li><p>构造数据类型由基本数据类型或构造数据类型组成</p>
</li>
<li><p>构造数据类型由不同分类型组成</p>
</li>
</ul>
<ol>
<li><p>抽象数据类型的形式定义</p>
<ol>
<li><p>抽象数据类型用三元组表示(D,S,P)</p>
<ol>
<li>D数据对象</li>
<li>S是D上的关系集</li>
<li>P是对D的基本操作集</li>
</ol>
</li>
<li><p>ADT抽象数据类型名 {</p>
<p>​    数据对象:&lt;数据对象的定义&gt;</p>
<p>​    数据关系:&lt;数据关系的定义&gt;</p>
<p>​    基本操作:&lt;基本操作的定义&gt;</p>
<p>}ADT抽象数据类型名</p>
</li>
</ol>
</li>
<li><p>ADT是指一个数据模型以及定义在该模型上的一组操作</p>
<ol>
<li>ADT<ol>
<li>数据逻辑结构</li>
<li>抽象运算</li>
</ol>
</li>
<li>对求解一个问题的形式化描述，面向用户，目的是使问题描述和问题实现相分离</li>
</ol>
</li>
<li><p>作用：有了ADT 程序员就可以将数据逻辑结构映射为存储结构，再在存储结构上设计抽象运算对应的算法，从而实现该ADT，一个数据类型可以看作是已经实现了抽象的数据类型。</p>
</li>
</ol>
<blockquote>
<p><strong>思考：数据类型与数据结构的区别和联系是什么？</strong></p>
<p>答:数据结构是相互之间存在一种成多种特定关系的数据元素的集合，一般包括数据逻辑结构、存储结构和数据的运算3方面的内容。</p>
<p>而数据类型是一个值的集合和定义在这个值集上的一组运算的总称，例如，C语言** *<em>short int</em>***数据类型(短整型)的值集合为-32768～32767，一组运算是+、-、*、/,%等.</p>
<p>可以将一种数据类型看成是一种实现了的数据结构。**</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><strong>数据结构的三个方面：</strong></li>
</ul>
<ol>
<li>数据的逻辑结构<ol>
<li>线性结构<ol>
<li>线性表</li>
<li>栈</li>
<li>队</li>
</ol>
</li>
<li>非线性结构<ol>
<li>树</li>
<li>图</li>
</ol>
</li>
</ol>
</li>
<li>数据的存储结构<ol>
<li>顺序存储</li>
<li>链式存储</li>
</ol>
</li>
<li>数据的操作<ol>
<li>增</li>
<li>删</li>
<li>改</li>
<li>查</li>
</ol>
</li>
</ol>
<ul>
<li>*<em>数据结构</em>***是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。</li>
<li>换句话说，数据结构是带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系。</li>
<li>或者说数据结构就是数据元素的组织形式。**</li>
</ul>
<h3 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h3><p><strong>1. 简述下列概念：数据、数据元素、数据项</strong></p>
<p><strong>数据对象、数据结构、逻辑结构、存储结构</strong></p>
<p><strong>抽象数据类型。</strong></p>
<p><strong>2. 写一个函数find，实现从数组a[n]查找元素x，返回x在数组中的序号，如果找不到则返回-1。</strong></p>
<p><strong>3. 当a[n]递增有序时，有没有高效的算法？</strong></p>
<p>1.</p>
<p>（1）数据：指的是在计算机科学中所有能输入到计算机中并被计算机程序处理的符号到总称。</p>
<p>（2）数据元素：是数据的基本单位。</p>
<p>（3）数据项：若干数据项可组成一个数据元素。</p>
<p>（4）数据对象：性质相同的数据元素的集合。</p>
<p>（5）数据结构：是相互之间存在一种或者多种特定关系的数据元素的集合。</p>
<p>（6）逻辑结构：数据元素之间的相互关系，可分为集合，线性结构，树形结构，图状结构。</p>
<p>（7）存储结构：包括数据元素的表示和关系的表示。分为顺序存储结构和链式存储结构。</p>
<p>（8）抽象数据类型：ADT=数据对象+数据关系+基本操作。</p>
<p>2.数组无序，采取遍历数组形式查找；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]==x)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(a);</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你想查找的整数\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">find</span>(a,n,x);</span><br><span class="line">    <span class="keyword">if</span> (k!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了，在索引%d位置&quot;</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.当有序时，可以采用二分查找法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = a[mid];</span><br><span class="line">        <span class="keyword">if</span> (middle &lt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (middle &gt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a);</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n请输人所要查找的元素：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">int</span> result = find(a, n, x);</span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了,在位置%d\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没找到\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、算法分析"><a href="#四、算法分析" class="headerlink" title="四、算法分析"></a>四、算法分析</h3><ul>
<li><p>算法：</p>
<ul>
<li>是对特定问题求解步骤的一种描述,是一个有穷的指令集，这些指令表示一个或多个操作</li>
<li>特性；<ul>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
<li>输入</li>
<li>输出</li>
</ul>
</li>
</ul>
</li>
<li><p>好算法的标准</p>
<ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效率与低存储</li>
</ul>
</li>
<li><p>算法的事前估计</p>
<ul>
<li>时间复杂度</li>
<li>运行时间=算法中每条语句执行时间之和</li>
<li>每条语句执行时间=该语句的执行次数*该语句执行一次所需要的时间</li>
</ul>
</li>
<li><p>常见算法时间复杂度</p>
<ul>
<li>O(1) : 表示算法的运行时间为常量</li>
<li> O(n) : 表示该算法是线性算法</li>
<li> O(logn): 二分查找算法</li>
<li> O(n2) : 对数组进行排序的各种简单算法，例如直接插入排序的算法。</li>
<li> O(n3) : 做两个n阶矩阵的乘法运算</li>
<li> O(2n) : 求具有n个元素集合的所有子集的算法</li>
<li> O(n!) : 求具有N个元素的全排列的算法</li>
</ul>
</li>
<li><p>**O(1)&lt;O(㏒n)&lt;O(n)&lt;O(**<strong>n㏒n)&lt; O(n2)&lt;)&lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn)</strong></p>
</li>
<li><p>空间复杂度</p>
<ul>
<li><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的度量，记作：</p>
</li>
<li><p>   S(n) = O(g(n))</p>
</li>
<li><p>表示随着问题规模n的增大，算法运行所需存储量的增长率与g(n)的增长率相同。</p>
</li>
<li><p>算法的存储量包括：</p>
<p>1．输入数据所占空间; </p>
<p>2．程序本身所占空间； </p>
<p>3．辅助变量所占空间。 </p>
</li>
</ul>
</li>
<li><p>存储空间的两个部分</p>
<ul>
<li><p><strong>存储空间的固定部分</strong>**</p>
<ul>
<li>程序指令代码的空间，常数、简单变量、定长成分(如数组元素、结构成分、对象的数据成员等)变量所占空间</li>
</ul>
</li>
<li><p>可变部分</p>
<ul>
<li> 尺寸与实例特性有关的成分变量所占空间、引用变量所占空间、递归栈所用空间、通过new和delete命令动态使用空间**</li>
</ul>
</li>
<li><p><strong>注意：一个算法的临时存储空间是指函数内新开辟的空间，不包括形参占用的空间</strong></p>
</li>
<li><p>```C<br>int fun (int a[], int n){ int i,s=0;<br>for(i=0; i=n; i++) </p>
<pre><code>s+=a[i];
</code></pre>
<p>return s; </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - **函数体内只开辟了****i，s变量空间，与n无关，所以空间复杂度为O(1)。不计形参a占用的空间。**</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### 作业二</span><br><span class="line"></span><br><span class="line">- **1.**   **以Niklus Wirth的观点，程序是什么?** </span><br><span class="line"></span><br><span class="line">  - **程序=数据结构+算法**</span><br><span class="line"></span><br><span class="line">- **2.**   **算法有什么特性？**</span><br><span class="line"></span><br><span class="line">  - **有穷性，确定性，可行性，输入，输出**</span><br><span class="line"></span><br><span class="line">- **3.**   **好算法应满足哪些标准？**</span><br><span class="line"></span><br><span class="line">  - **正确性，可读性，健壮性，高效率和低存储的需求**</span><br><span class="line"></span><br><span class="line">- **4.**   **数据结构主要在哪些层面上讨论问题？**</span><br><span class="line"></span><br><span class="line">  - **主要在逻辑结构，存储结构和运算这三个层面上讨论问题**</span><br><span class="line"></span><br><span class="line">- **5. 分析下列算法的时间复杂度**</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">   for(i=0;i&lt;n;i++)</span><br><span class="line">  </span><br><span class="line">    for(j=0;j&lt;m;j++)</span><br><span class="line">  </span><br><span class="line">     a[i][j]=0;</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p><strong>频度为m*n —n^2</strong></p>
</li>
<li><p>T(n)=O(n^2)</p>
</li>
</ul>
</li>
<li><p>```c<br> s=0;<br> for(i＝0; i＜n;i++)</p>
<p>  for(j＝0;j&lt;n;j++)</p>
<p>s+＝B[i][j]<br> sum=s;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - **频度为 2+n^2**</span><br><span class="line">  - **T(n)=O(n^2)**</span><br><span class="line"></span><br><span class="line">- **(3)**</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  i=1；</span><br><span class="line">   while(i&lt;=n)</span><br><span class="line">   i=i\*3;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>3^k=n 所以 k=log3 n</strong></li>
<li><strong>T(n)=O(log3 n)</strong></li>
</ul>
</li>
<li><p>```c<br> x=0;<br> for(i＝1;i＜n;i++)</p>
<p>  for(j＝1;j&lt;＝n-1;j++)</p>
<pre><code>x++;
</code></pre>
<p>sum=s;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - **频度为 n\*(n-1)**</span><br><span class="line">  - **T(n)=O(n^2)**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 第二章 线性表</span><br><span class="line"></span><br><span class="line">**1.** **了解线性结构的特点**</span><br><span class="line"></span><br><span class="line">**2.********掌握顺序表的定义、查找、插入和删除**</span><br><span class="line"></span><br><span class="line">**3.****掌握链表的定义、创建、查找、插入和删除**</span><br><span class="line"></span><br><span class="line">**4.****能够从时间和空间复杂度的角度比较两种存储结构的不同特点及其适用场合**</span><br><span class="line"></span><br><span class="line">1. 线性结构特点</span><br><span class="line"></span><br><span class="line">   在数据元素的非空有限集合中，同一线性表中元素具有相同特性，相邻元素之间存在序偶关系</span><br><span class="line"></span><br><span class="line">   1. 存在唯一一个被叫做第一个的数据元素</span><br><span class="line">   2. 存在唯一一个被叫做最后一个的数据元素</span><br><span class="line">   3. 除第一个元素外，每个数据元素均有唯一一个直接前驱</span><br><span class="line">   4. 除最后一个元素外，每个元素都有唯一一个直接后继</span><br><span class="line"></span><br><span class="line">2. 线性表</span><br><span class="line"></span><br><span class="line">   1. 是一种典型的线性结构</span><br><span class="line">   2. 数据的运算是定义在逻辑结构上的，而运算的具体实现则是在存储结构上进行的</span><br><span class="line"></span><br><span class="line">3. 线性表的存储结构</span><br><span class="line"></span><br><span class="line">   1. 顺序表</span><br><span class="line"></span><br><span class="line">      把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里，用这种方法存储的线性表简称顺序表</span><br><span class="line"></span><br><span class="line">      1. 逻辑上相邻，物理上也相邻</span><br><span class="line">      2. 顺序存储方法:用一组地址连续的存储单元存储线性表的元素，可通过数组V[n]实现</span><br><span class="line"></span><br><span class="line">   2. 顺序存储</span><br><span class="line"></span><br><span class="line">      1. 定义：将线性表中元素相继存放在一个连续的存储空间中</span><br><span class="line">      2. 存储结构：数组</span><br><span class="line">      3. 特点：顺序存储</span><br><span class="line">      4. 存取方式：随机存取</span><br><span class="line"></span><br><span class="line">4. 顺序表的存储结构定义</span><br><span class="line"></span><br><span class="line">### 静态分配的顺序表</span><br><span class="line"></span><br><span class="line">1. 静态分配的顺序表存储</span><br><span class="line"></span><br><span class="line">   1. ```c</span><br><span class="line">      #define  ListSize  100           //最大允许长度</span><br><span class="line">      typedef  struct &#123; </span><br><span class="line">              ListData  data[ListSize] ;      //存储空间</span><br><span class="line">              int  length;                      //当前元素个数</span><br><span class="line">          &#125; SeqList;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>静态存储的基本操作</p>
<p>1.InitList(&amp;L)；初始化线性表L为空表；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span> <span class="params">( SeqList  &amp;L )</span></span></span><br><span class="line"><span class="function"></span>&#123;                           <span class="comment">//初始化表L为空表</span></span><br><span class="line">     L.length = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>2、DestroyList(&amp;L)回收(销毁)线性表L</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span><span class="comment">//销毁线性表L </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (L.data)&#123;</span><br><span class="line">		<span class="keyword">delete</span> L.data;<span class="comment">//释放存储空间(删除此数组)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、 ClearList(&amp;L)  清空线性表L</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList</span><span class="params">(SeqList &amp;L)</span>     <span class="comment">//清空线性表L</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   L.length=<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 4、 **ListEmpty(SeqList **L) 判断线性表L是否为空，若为空返回1,否则返回0；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListEmpty</span><span class="params">(SeqList L)</span> </span>&#123;<span class="comment">//若线性表L为空返回1,否则返回****0**</span></span><br><span class="line">      <span class="keyword">return</span>(!(L.length)) ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 5、 ListLength ( L ) 求表L的长度 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span> <span class="params">( SeqList L )</span></span></span><br><span class="line"><span class="function"> </span>&#123;                            <span class="comment">//函数值是表L的长度</span></span><br><span class="line">  <span class="keyword">return</span>(L.length);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 6、 GetElem ( L, i ) 函数值为线性表L中第 i个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function">ListData <span class="title">GetElem</span> <span class="params">( SeqList L, <span class="keyword">int</span> i )</span> </span>&#123; <span class="comment">//函数值为表L中第 i 个元素</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>&lt;=i &amp;&amp; i &lt;= L.length )      </span><br><span class="line">    <span class="keyword">return</span> (L.data[i<span class="number">-1</span>]); <span class="comment">//第i-1的单元存储着第i个数据</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> “Error”;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 7-1、LocateElem( L, x ) 查找x在表L中的位置, 若查找成功，返回x的位置，否则返回-1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">( SeqList L, ListData x )</span> </span>&#123;<span class="comment">//查找x在表  </span></span><br><span class="line">      </span><br><span class="line">   <span class="comment">//L中位置, 若查找成功，返回x的位置，否则返回-1</span></span><br><span class="line">      </span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line"> <span class="keyword">while</span> ((i&lt;L.length)&amp;&amp;(L.data[i]!=x)) i++;  <span class="comment">//查找</span></span><br><span class="line">      </span><br><span class="line"> <span class="keyword">if</span> ( i&lt;L.length ) <span class="keyword">return</span> i;                  <span class="comment">//成功</span></span><br><span class="line">      </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;                           <span class="comment">//失败</span></span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7-2、 IsIn ( L, x ) 判断x是否在表L中，是返回1否则返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsIn</span> <span class="params">( SeqList L, ListData x )</span> </span>&#123; <span class="comment">//判断x是否在表L中</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">//x在L中返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, found=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((i&lt; L.length)&amp;&amp;!found )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(L.data[i]!= x ) i++;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">else</span> found=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> found;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、 NextElem (L, x ) 求x的直接后继</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextElem</span> <span class="params">( SeqList L, ListData x )</span> </span>&#123; <span class="comment">//如果x在表L中且</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//有直接后继，函数值返回其直接后继的位置，否则返回-1</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> ((i&lt;L.length)&amp;&amp;(L.data[i]!=x)) i++;  <span class="comment">//查找x</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ((<span class="number">0</span>&lt;=i)&amp;&amp;(i&lt;L.length<span class="number">-1</span>)) <span class="keyword">return</span> i+<span class="number">1</span>;      </span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>9、 PriorElem (L, x )求x的直接前驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PriorElem</span> <span class="params">( SeqList L, ListData x )</span> </span>&#123;  <span class="comment">//如果x在表L中且</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment">//有直接前驱，函数值返回其直接后继的位置，否则返回-1</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">while</span> (i&lt; L.length &amp;&amp; L.data[i]!=x) i++;     <span class="comment">//查找x</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> ((<span class="number">0</span>&lt; i)&amp;&amp;(i&lt;L.length)) <span class="keyword">return</span> i<span class="number">-1</span>;   <span class="comment">//返回位置</span></span><br><span class="line">      </span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10、ListInsert (&amp;L, i, x ) 在顺序表L中第 i 个元素前插入 x,插入成功返回1，不成功 返回0 n/2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span> <span class="params">( SeqList &amp;L, <span class="keyword">int</span> i , ListData x)</span> </span>&#123; <span class="comment">//在顺序表L中</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//第 i 个元素前插入 x,插入成功返回1，不成功 返回0</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ((i &lt; <span class="number">1</span>)||(i &gt;L.length+<span class="number">1</span>)||(L.length==ListSize))</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;                            <span class="comment">//插入不成功 </span></span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="keyword">for</span> ( <span class="keyword">int</span> j = L.length; j &gt;i<span class="number">-1</span>; j-- )           <span class="comment">//后移</span></span><br><span class="line">        L.data[j]=L.data[j<span class="number">-1</span>]; </span><br><span class="line">      L.data[i<span class="number">-1</span>]=x;  L.length++; <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//插入成功    </span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11、ListDelete (&amp;L, i) 在顺序表L中删除第i个元素删除成功返回1，否则返回0 (n-1)/2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span> <span class="params">( SeqList &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//在顺序表L中删除第i个元素,</span></span><br><span class="line">                          <span class="comment">//成功返回1，否则返回0</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span>)||(i&gt;L.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">L.length -- ; </span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> j = i<span class="number">-1</span>; j &lt; L.length+<span class="number">1</span>; j++ )    <span class="comment">//前移</span></span><br><span class="line">  L.data[j]=L.data[j+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;                      <span class="comment">//成功删除 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法时间复杂度分析</p>
<p>​    查找、插入、删除的平均时间复杂度为 O(n)</p>
<p>空间复杂度为S(n) = O(1) 没有占用辅助空间</p>
</li>
</ol>
</li>
</ul>
<h3 id="动态分配的顺序表"><a href="#动态分配的顺序表" class="headerlink" title="动态分配的顺序表"></a>动态分配的顺序表</h3><ol>
<li><p>动态分配的顺序表存储</p>
<ol>
<li><p>动态分配顺序存储结构</p>
<ol>
<li>```c<br>#define LIST_INIT_SIZE 10    // 线性表存储空间的初始分配量<br>#define LISTINCREMENT 5 // 线性表存储空间的分配增量<br> typedef struct<br> {<br>  ListData *data;     // 存储空间基址<br>  int length;     // 顺序表当前长度<br>  int listsize;// 当前分配的存储容量(以sizeof(ListData)为单位<br> }SqList;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 基本操作</span><br><span class="line"></span><br><span class="line">   1、InitList(&amp; L)；初始化线性表L为空表；</span><br><span class="line"></span><br><span class="line">   ```c</span><br><span class="line">   int InitList(SqList &amp;L)</span><br><span class="line">   &#123;                 // 分配指定大小的存储空间给顺序表</span><br><span class="line">    L.data = (ListData*)malloc(LIST_INIT_SIZE*sizeof(ListData));  //分配存储单元</span><br><span class="line">    if( !L.data )                  // 存储分配失败</span><br><span class="line">   		 exit(0);</span><br><span class="line">   L.length = 0;               // 当前长度初始化为0</span><br><span class="line">   L.listsize = LIST_INIT_SIZE; // 指定分配的存储容量 </span><br><span class="line">    return 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2、DestroyList(&amp;L) 回收顺序线性表L，将顺序表结构体中的所有成员销毁（空间释放， 数值置0）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;           <span class="comment">// 先释放空间，然后置空</span></span><br><span class="line"> <span class="built_in">free</span>( L.data );</span><br><span class="line"> L.length = <span class="number">0</span>;</span><br><span class="line"> L.listsize = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3、 ClearList(&amp;L)  清空线性表L</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">ClearList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;          <span class="comment">//清空线性表L</span></span><br><span class="line"> L.length = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 4、 ListEmpty(SeqList L) 判断线性表L是否为空，若为 </p>
<p>​    空返回1,否则返回0；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListEmpty</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">return</span>(!(L.length))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、 ListLength (L ) 求表L的长度 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// L.length记录当前顺序表的长度，直接返回</span></span><br><span class="line"><span class="keyword">return</span> (L.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 6、 GetElem ( L, i ) 函数值为表L中第 i个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListData <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//函数值为表L中                               //第 i 个元素</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">1</span>&lt;=i &amp;&amp; i &lt;= L.length )      </span><br><span class="line">    <span class="keyword">return</span> (*(L.data+i<span class="number">-1</span>));</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line"> &#125;     </span><br></pre></td></tr></table></figure>

<p>7-1、LocateElem(L, x ) 查找x在表L中的位置, 若查找成功，返回x的位置，否则返回-1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">( SqList L, ListData x )</span> </span>&#123;<span class="comment">//查找x在表  </span></span><br><span class="line">    <span class="comment">//L中位置, 若查找成功，返回x的位置，否则返回-1</span></span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> ((i&lt;L.length)&amp;&amp;(*(L.data+i)!=x)) i++;  <span class="comment">//查找</span></span><br><span class="line"> <span class="keyword">if</span> ( i&lt;L.length ) <span class="keyword">return</span> i;                  <span class="comment">//成功,返回位置</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;                          <span class="comment">//失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7-2、 IsIn ( L, x ) 判断x是否在表L中，是返回1否则返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsIn</span> <span class="params">( SqList L, ListData x )</span> </span>&#123; <span class="comment">//判断x是否在表L中</span></span><br><span class="line">               <span class="comment">//x在L中返回1，否则返回0</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, found=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((i&lt; L.length)&amp;&amp;!found )</span><br><span class="line">  <span class="keyword">if</span>(*(L.data+i)!= x ) i++;</span><br><span class="line">     <span class="keyword">else</span> found=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、 NextElem (L, x ) 求x的直接后继</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextElem</span> <span class="params">( SqList L, ListData x )</span> </span>&#123; <span class="comment">//如果x在表L中且</span></span><br><span class="line">   <span class="comment">//有直接后继，函数值返回其直接后继的位置，否则返回-1</span></span><br><span class="line"> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> ((i&lt;L.length)&amp;&amp;(*(L.data+i)!=x)) i++;  <span class="comment">//查找x</span></span><br><span class="line"> <span class="keyword">if</span> ((<span class="number">0</span>&lt;=i)&amp;&amp;(i&lt;L.length<span class="number">-1</span>)) <span class="keyword">return</span> i+<span class="number">1</span>;      </span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>9、 PriorElem (L, x )求x的直接前驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PriorElem</span> <span class="params">( SqList L, ListData x )</span> </span>&#123;  <span class="comment">//如果x在表L中且</span></span><br><span class="line">  <span class="comment">//有直接前驱，函数值返回其直接后继的位置，否则返回-1</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt; L.length &amp;&amp; *(L.data+i)!=x) i++;     <span class="comment">//查找x</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="number">0</span>&lt; i)&amp;&amp;(i&lt;L.length)) <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10、ListInsert (&amp;L, i, e) 在顺序表L中第 i 个元素前插入e,成功返回1，否则返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ListData e)</span></span></span><br><span class="line"><span class="function"></span>&#123;ListData *newbase, *q, *p;</span><br><span class="line"><span class="keyword">if</span>((i &lt; <span class="number">1</span>) || (i &gt; L.length + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">//输入的i不合法</span></span><br><span class="line"><span class="keyword">if</span>( L.length == L.listsize)              <span class="comment">// 当前存储空间已满, 增加分配空间</span></span><br><span class="line"> &#123;      <span class="comment">// realloc改变L.data所指内存的大小，原始所指内存中的数据不变。</span></span><br><span class="line">  newbase = (ListData *)<span class="built_in">realloc</span>(L.data, (L.listsize + LISTINCREMENT) * <span class="keyword">sizeof</span>(ListData));</span><br><span class="line">  <span class="keyword">if</span>( !newbase ) <span class="built_in">exit</span>(<span class="number">0</span>);                               <span class="comment">//申请新空间失败</span></span><br><span class="line">   L.data = newbase;                              <span class="comment">// 新基址</span></span><br><span class="line">   L.listsize += LISTINCREMENT;                  <span class="comment">// 增加存储容量</span></span><br><span class="line">  &#125;</span><br><span class="line"> q = L.data + i - <span class="number">1</span>;                                  <span class="comment">// 指定插入的位置</span></span><br><span class="line"> <span class="keyword">for</span>(p = L.data + L.length - <span class="number">1</span>; p &gt;= q; --p) *(p+<span class="number">1</span>) = *p;   <span class="comment">// q之后的元素右移</span></span><br><span class="line"> *q = e;  ++L.length; <span class="keyword">return</span> <span class="number">1</span>;             <span class="comment">// 插入e ，表长增1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11、ListDelete (&amp;L, i) 在顺序表L中删除第i个元素，成功返回1，否则返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123; ListData *p,*q;</span><br><span class="line">  <span class="keyword">if</span>( i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">// i值不合法</span></span><br><span class="line">  p = L.data + i - <span class="number">1</span>;  <span class="comment">// p为被删除元素的位置</span></span><br><span class="line">  q = L.data + L.length<span class="number">-1</span>;        <span class="comment">// 表尾元素的位置</span></span><br><span class="line">  <span class="keyword">for</span>(++p; p &lt;= q; ++p) <span class="comment">// 被删除元素之后的元素左移</span></span><br><span class="line"> *(p<span class="number">-1</span>) = *p;</span><br><span class="line"> L.length--; <span class="comment">// 表长减1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺序表的优缺点</p>
<ul>
<li>优点 <ul>
<li>存储密度大</li>
<li>可以随机存取表中任一元素</li>
</ul>
</li>
<li>缺点<ul>
<li>在插入删除某一元素时，需要移动大量元素</li>
<li>浪费存储空间</li>
<li>属于静态存储形式，数据元素的个数不能自由扩充</li>
<li>克服这一缺点-》链表</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="第二章作业一"><a href="#第二章作业一" class="headerlink" title="第二章作业一"></a>第二章作业一</h3><p>已知长度为n的线性表A采用顺序存储结构，请写一时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除线性表中所有值为item的数据元素。</p>
<p>解：</p>
<p>（1）算法思路</p>
<p>时间复杂度为O(n)即for 或者 while出现的次数最多为一次，空间复杂度为O(1)即在删除item过程中不能重新开辟一个数组，分配的空间不随处理数据量变化。则能想到用一个临时变量存储单次遍历中与item值不相同的值，并在当前循环中把值覆盖到原本线性表中从j==0开始的data[j]中，并且每次赋值后j递增1，遍历后所得的j即为新的线性表长度，最后赋值给length即完成顺序表删除相同元素并且改变线性表长度的操作。</p>
<p>（2）算法实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ListSize 10<span class="comment">//最大允许长度</span></span></span><br><span class="line"><span class="comment">//静态分配的顺序表存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ListData;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  ListData data[ListSize]; <span class="comment">//存储个数</span></span><br><span class="line">  <span class="keyword">int</span> length;<span class="comment">//当前元素个数</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//删除线性表中item值元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteItem</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> item)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp; <span class="comment">//储存临时变量</span></span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123; <span class="comment">//遍历顺序表</span></span><br><span class="line">    <span class="keyword">if</span>(L.data[i]!=item)&#123;</span><br><span class="line">      temp=L.data[i]; <span class="comment">//不等于item的线性表元素值存储到临时变量中</span></span><br><span class="line">      L.data[j]=temp; <span class="comment">//替换掉索引为j的线性表元素</span></span><br><span class="line">      j++; <span class="comment">//每替换一次 j的值加一</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  L.length=j; <span class="comment">//线性表长度缩小为j</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  SqList SL;</span><br><span class="line">  InitList(SL);</span><br><span class="line">  SL.length=<span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123; <span class="comment">//给线性表赋值，偶数索引对应值为2 单数索引对应值为1+i</span></span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">      j=<span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> j=<span class="number">1</span>+i;</span><br><span class="line">    SL.data[i]=j;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SL.length;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SL[%d]=%d\n&quot;</span>,i,SL.data[i]); <span class="comment">//打印顺序表中的值</span></span><br><span class="line">  &#125;</span><br><span class="line">  DeleteItem(SL, <span class="number">2</span>); <span class="comment">//删除item==2的顺序表元素</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SL.length;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SL[%d]=%d\n&quot;</span>,i,SL.data[i]); <span class="comment">//打印删除相同item后的顺序表</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性表的链式存储结构-链表-Linked-List"><a href="#线性表的链式存储结构-链表-Linked-List" class="headerlink" title="线性表的链式存储结构 链表(Linked List)"></a>线性表的链式存储结构 链表(Linked List)</h3><ul>
<li>单链表</li>
<li>静态链表</li>
<li>循环链表</li>
<li>双向链表</li>
</ul>
<p>链式存储有关术语</p>
<ol>
<li><p>结点：数据元素的存储映像，由数据域和指针域组成</p>
</li>
<li><p>链表：n个结点由指针链组成一个链表，它是线性表存储映像，称为线性表的链式存储结构</p>
</li>
<li><p>单链表、双链表、循环链表：</p>
<ol>
<li>结点只有一个指针域，称为单链表或线性链表</li>
<li>有两个指针域的链表，称为双链表</li>
<li>首尾相接的链表称为循环链表</li>
</ol>
</li>
<li><p>头指针、头结点和首元节点:</p>
<ol>
<li>头指针是指向链表中第一个结点的指针</li>
<li>首元结点是指链表中存储第一个数据元素a1的结点</li>
<li>头结点是在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信息</li>
</ol>
</li>
<li><p>在链表中设置头节点有什么好处</p>
<ol>
<li>便于首元结点处理</li>
<li>便于空表和非空表的统一处理</li>
</ol>
</li>
<li><p>头结点的数据域内装的是什么</p>
<ol>
<li>头结点的数据域可以为空，也可存放线性表长度等附加信息，但此结点不可以计入链表长度值</li>
</ol>
</li>
<li><p>链式（链式存储结构）的特点</p>
<ol>
<li>结点在存储器的位置不是任意的，即逻辑上相邻的数据元素在物理上的不一定相邻</li>
<li>访问时只能通过头指针进入链表，并通过每个结点的结点的指针域后扫描其余结点，所以寻找第一个结点和最后一个结点所话费的时间不等</li>
<li>顺序存储</li>
</ol>
<p>链表的优缺点</p>
<ul>
<li>优点<ul>
<li>数据元素的个数可以自由扩充</li>
<li>插入、删除等操作不必移动元素，只需修改链接指针，修改效率较高</li>
</ul>
</li>
<li>缺点<ul>
<li>存储密度小</li>
<li>存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表结构定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ListData;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>              <span class="comment">//链表结点 </span></span><br><span class="line">   ListData  data;            <span class="comment">//结点数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">next</span>;</span>            <span class="comment">//结点链域</span></span><br><span class="line"> &#125; ListNode;</span><br><span class="line"><span class="keyword">typedef</span> ListNode * LinkList;      <span class="comment">//链表头指针</span></span><br></pre></td></tr></table></figure>

<p>1.InitList(&amp;first)；初始化单链表first为空表；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(LinkList  &amp;first)</span></span>&#123;  <span class="comment">//初始化单链表first为空表</span></span><br><span class="line">    first=<span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>2、DestroyList(&amp;first) 销毁单链表first</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(LinkList &amp;first)</span> </span>&#123;</span><br><span class="line">                      <span class="comment">//删去单链表first的所有结点</span></span><br><span class="line">  ListNode *q;</span><br><span class="line">  <span class="keyword">while</span> (first ) &#123;</span><br><span class="line">              <span class="comment">//当链不空时，循环逐个删去所有结点</span></span><br><span class="line">     q =first；first= first→next;</span><br><span class="line">    <span class="built_in">free</span>( q );    <span class="comment">//释放 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3、 ClearList(&amp;first)  清空单链表first</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span> <span class="params">( LinkList  &amp;first )</span> </span>&#123;</span><br><span class="line">                      <span class="comment">//删去单链表first中所有结点</span></span><br><span class="line">  ListNode *q;</span><br><span class="line">  <span class="keyword">while</span> (first ) &#123;</span><br><span class="line">              <span class="comment">//当链不空时，循环逐个删去所有结点</span></span><br><span class="line">     q =first; first = first→next;</span><br><span class="line">    <span class="built_in">free</span>( q );    <span class="comment">//释放 </span></span><br><span class="line">   &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 4、 ListEmpty(first) 判断单链表first是否为空，若为空返回1, 否则返回0；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListEmpty</span><span class="params">(LinkList first)</span></span></span><br><span class="line"><span class="function"> </span>&#123;            <span class="comment">//若单链表first为空返回1,否则返回0</span></span><br><span class="line">    <span class="keyword">return</span> !first ;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>5、 ListLength ( first ) 求单链表first的长度 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(LinkList first)</span>  <span class="comment">//函数值为单链表first长度</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p=first;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">      p=p→next;     count++;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> 6、 GetElem ( first, i ) 函数值为单链表first中第 i个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListData <span class="title">GetElem</span><span class="params">(LinkList first, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//函数返回单链表first中第i个元素值，不存在返回NULL</span></span><br><span class="line">  LinkList p;    <span class="keyword">int</span> j;</span><br><span class="line">  p=first; j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (p&amp;&amp;(j&lt;i)) &#123;               <span class="comment">//找第i个元素</span></span><br><span class="line">    p=p→next; ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!p||j&gt;i) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">//第i个元素不存在,p 空没找到</span></span><br><span class="line">                        <span class="comment">//j&gt;i 是输入i&lt;1的情况</span></span><br><span class="line">  <span class="keyword">return</span> p→data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 7-1、LocateElem( first, x ) 查找x在单链表first中位置, 若查找成功，返回x的位置，否则返回NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">LocateElem</span><span class="params">( LinkList first, ListData x )</span> </span>&#123;<span class="comment">//在单链表first中</span></span><br><span class="line">    <span class="comment">//搜索数据值为x的结点，成功返回x第一次出现的位置，否则返回NULL</span></span><br><span class="line">   ListNode * p = first;        <span class="comment">//指针 p 指示第一个结点</span></span><br><span class="line">   <span class="keyword">while</span> ( p &amp;&amp; (p→data != x)) </span><br><span class="line">     p = p→next;</span><br><span class="line">   <span class="keyword">return</span> p;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7-2、 IsIn ( first, x ) 若x在单链表first中函数返回1否则返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">IsIn</span> <span class="params">(( LinkList first, ListData x )</span></span></span><br><span class="line"><span class="params"><span class="function">  &#123;               <span class="comment">//若x在单链表first中函数返回1否则返回0</span></span></span></span><br><span class="line"><span class="params"><span class="function">  ListNode * p = first;            <span class="comment">//指针 p 指示第一个结点</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">while</span> ( p &amp;&amp; (p→data != x))    <span class="comment">//找x</span></span></span></span><br><span class="line"><span class="params"><span class="function">    p = p→next;</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">return</span> !(p==<span class="literal">NULL</span>);   </span></span></span><br><span class="line"><span class="params"><span class="function">&#125; </span></span></span><br></pre></td></tr></table></figure>

<p>8、 NextElem (first, x ) 求x的直接后继</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">NextElem</span><span class="params">(LinkList first, ListData x)</span> </span>&#123; </span><br><span class="line">  <span class="comment">//函数返回单链表//first中值为x结点的直接后继结点地址，没有返回NULL</span></span><br><span class="line"> LinkList p=first;</span><br><span class="line"> <span class="keyword">while</span>(p&amp;&amp;p→data!=x)              <span class="comment">//找x</span></span><br><span class="line">     p=p→next;</span><br><span class="line"> <span class="keyword">if</span> (!p || ! p→next) <span class="keyword">return</span> <span class="literal">NULL</span>;      <span class="comment">//没有直接后继</span></span><br><span class="line"> <span class="keyword">return</span> p→next;          </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>9、 PriorElem (first, x )求x的直接前驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">PriorElem</span><span class="params">(LinkList first, ListData x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     <span class="comment">//函数返回x的直接前驱的结点地址，没有返回NULL</span></span><br><span class="line"> LinkList p=first;</span><br><span class="line"> <span class="keyword">while</span>(p&amp;&amp;p→next &amp;&amp;(p→next→data!=x))        <span class="comment">//找x</span></span><br><span class="line">     p=p→next;</span><br><span class="line"> <span class="keyword">if</span> (!p ||! p→next) <span class="keyword">return</span> <span class="literal">NULL</span>;         <span class="comment">//没有直接前驱</span></span><br><span class="line"> <span class="keyword">return</span> p;          </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>10、 ListInsert (&amp;first, i, x )在单链表first第 i 个元素结点前插入元素 x</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span> <span class="params">( LinkList &amp;first, <span class="keyword">int</span> i, ListData x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在单链表first中第 i 个元素结点前插入元素 x，成功返回1否则返回0</span></span><br><span class="line"> newnode=(ListNode *) <span class="built_in">malloc</span> ( <span class="keyword">sizeof</span> (ListNode) );</span><br><span class="line"> newnode→data = x;                 <span class="comment">//创建新结点</span></span><br><span class="line"> <span class="keyword">if</span> (i==<span class="number">1</span>) &#123;                   <span class="comment">//插入为第一个结点</span></span><br><span class="line">     newnode→next = first;         <span class="comment">//新结点成为第一个结点</span></span><br><span class="line">     first = newnode;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">   &#125; </span><br><span class="line"> p = first;  k = <span class="number">1</span>; &#123;     <span class="comment">//插入位置不是第一个结点</span></span><br><span class="line"> <span class="keyword">while</span> ( p &amp;&amp; k &lt; i<span class="number">-1</span>) </span><br><span class="line">   &#123; p = p→next; k++; &#125;  <span class="comment">//移动指针，找第 i-1个结点</span></span><br><span class="line"> <span class="keyword">if</span> ( !p || i&lt;<span class="number">1</span>) ) &#123; </span><br><span class="line">   <span class="built_in">printf</span> ( “无效的插入位置!\n” );        <span class="comment">//终止插入</span></span><br><span class="line">     <span class="built_in">free</span>(newnode);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> newnode→next = p→next;       </span><br><span class="line"> p→next = newnode;              <span class="comment">//插在表中间或末尾</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11、ListDelete (&amp;first, i )在单链表first中删除第 i 个结点，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span> <span class="params">( LinkList &amp;first, <span class="keyword">int</span> i )</span> </span>&#123; </span><br><span class="line">        <span class="comment">//在单链表first中删除第 i 个结点，删除成功返回1否则返回0</span></span><br><span class="line">  <span class="keyword">if</span> ( first&amp;&amp;i == <span class="number">1</span> )             <span class="comment">//删除表中第 1 个结点</span></span><br><span class="line">    &#123; q = first; first = first→next; &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    p = first;  k = <span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">while</span> ( p &amp;&amp; k &lt; i<span class="number">-1</span> )</span><br><span class="line">      &#123; p = p→next; k++; &#125;           <span class="comment">//找第 i-1个结点</span></span><br><span class="line">          <span class="keyword">if</span> ( !p  || !(p→next) || i&lt;<span class="number">1</span> ) &#123;                                                                                            <span class="comment">//找不到第i-1个结点</span></span><br><span class="line">            <span class="built_in">printf</span> ( “无效的删除位置!\n” );</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;q = p→next;                     <span class="comment">//删除中间结点或尾结点元素         </span></span><br><span class="line">                 p→next = q→next;        </span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">free</span> ( q ); <span class="keyword">return</span> <span class="number">1</span>;                                      <span class="comment">//释放q</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带头节点的单链表基本操作</p>
<p>1、InitList(&amp;first)；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化带头结点单链表first；</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(LinkList &amp;first)</span></span>&#123; </span><br><span class="line">                   <span class="comment">//初始化带头结点的单链表first为空表</span></span><br><span class="line">  first = (ListNode *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (ListNode) );  <span class="comment">//创建头结点 </span></span><br><span class="line">  first→next=<span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>2、DestroyList(&amp;first) 销毁带头节点单链表first</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(LinkList &amp;first)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//删去带头节点单链表first中的所有结点，包括头结点</span></span><br><span class="line">  ListNode *q;</span><br><span class="line">  <span class="keyword">while</span> (first ) &#123;</span><br><span class="line">              <span class="comment">//当链不空时，循环逐个删去所有结点</span></span><br><span class="line">     q =first；first= first→next;</span><br><span class="line">    <span class="built_in">free</span>( q );    <span class="comment">//释放 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3、 ClearList(&amp;first)  清空带头结点单链表first</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span> <span class="params">( LinkList  &amp;first )</span> </span>&#123;   <span class="comment">// 将表重置为空表</span></span><br><span class="line">          <span class="comment">//删去带头结点单链表first中的所有结点，保留头结点</span></span><br><span class="line"> ListNode *p, *q=first→next;</span><br><span class="line"> <span class="keyword">while</span> (q ) &#123;          <span class="comment">//当链不空时，循环逐个删去所有结点</span></span><br><span class="line">    p=q; q=q→next;</span><br><span class="line">   <span class="built_in">free</span>( p );          <span class="comment">//释放 </span></span><br><span class="line">  &#125; ;</span><br><span class="line"> first→next=<span class="literal">NULL</span>;   <span class="comment">//头结点指针域为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 4、 ListEmpty(LinkList first) 判断带头结点单链表first是否为空，若为空返回1,否则返回0；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListEmpty</span><span class="params">(LinkList first)</span></span></span><br><span class="line"><span class="function"> </span>&#123;            <span class="comment">//若带头结点单链表first为空返回1,否则返回0</span></span><br><span class="line">    <span class="keyword">return</span> !(first→next) ;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>5、 ListLength ( first ) 求带头结点单链表first的长度 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(LinkList first)</span> <span class="comment">//函数返回带头结点单链表first长度</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    p=first→next;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">      p=p→next;     count++;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> 6、 GetElem ( first, i ) 函数值为带头结点单链表first中第 i个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListData <span class="title">GetElem</span><span class="params">(LinkList first,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//函数返回带头结点单链表first第i个元素值，不存在返回NULL</span></span><br><span class="line">   LinkList p;    <span class="keyword">int</span> j;</span><br><span class="line">   p=first→next; j=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (p&amp;&amp;(j&lt;i)) &#123;               <span class="comment">//找第i个元素</span></span><br><span class="line">     p=p→next; ++j;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!p||j&gt;i) <span class="keyword">return</span> <span class="literal">NULL</span>;              <span class="comment">//第i个元素不存在</span></span><br><span class="line">   <span class="keyword">return</span> p→data;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 7-1、LocateElem( first, x ) 查找x在带头结点单链表first中的位置, 若查找成功，返回x的位置，否则返回NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">LocateElem</span><span class="params">( LinkList first, ListData x )</span> </span>&#123; <span class="comment">//在带头结点单//链表first中搜索其值为x的结点，查找成功返回x位置，否则返回NULL</span></span><br><span class="line">   ListNode * p = first→next;        <span class="comment">//指针 p 指示第一个结点</span></span><br><span class="line">   <span class="keyword">while</span> ( p &amp;&amp; (p→data != x)) </span><br><span class="line">     p = p→next;</span><br><span class="line">   <span class="keyword">return</span> p;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7-2、 IsIn ( first, x ) 若x在带头结点单链表first中函数返回1否则返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">IsIn</span> <span class="params">( LinkList first, ListData x )</span></span></span><br><span class="line"><span class="function">  </span>&#123;         <span class="comment">//若x在带头结点单链表first中函数返回1否则返回0</span></span><br><span class="line">  ListNode * p = first→next;            <span class="comment">//指针 p 指示第一个结点</span></span><br><span class="line">  <span class="keyword">while</span> ( p &amp;&amp; (p→data != x)) </span><br><span class="line">    p = p→next;</span><br><span class="line">  <span class="keyword">return</span> !(p==<span class="literal">NULL</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、 NextElem (first, x ) 在带头结点单链表first中求x的直接后继</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">NextElem</span><span class="params">(LinkList first, ListData x)</span> </span>&#123; <span class="comment">//函数返回带头结点单链表first中x的直接后继的结点地址，没有返回NULL</span></span><br><span class="line"> LinkList p=first→next;</span><br><span class="line"> <span class="keyword">while</span>(p&amp;&amp;p→data!=x)              <span class="comment">//找x</span></span><br><span class="line">     p=p→next;</span><br><span class="line"> <span class="keyword">if</span> (!p || ! p→next) <span class="keyword">return</span> <span class="literal">NULL</span>;      <span class="comment">//没有直接后继</span></span><br><span class="line"> <span class="keyword">return</span> p→next;          </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>9、 PriorElem (first, x )在带头结点单链表first中求x的直接前驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">PriorElem</span><span class="params">(LinkList first, ListData x)</span> </span>&#123; <span class="comment">//函数返回带头结点单链表first中x的直接前驱的结点地址，没有返回NULL</span></span><br><span class="line">LinkList p=first→next;</span><br><span class="line"> <span class="keyword">while</span>(p&amp;&amp;p→next &amp;&amp;(p→next→data!=x))           <span class="comment">//找x</span></span><br><span class="line">     p=p→next;</span><br><span class="line"> <span class="keyword">if</span> (!p||!p→next) <span class="keyword">return</span> <span class="literal">NULL</span>;              <span class="comment">//没有直接前驱 </span></span><br><span class="line"> <span class="keyword">return</span> p;         </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>10、 ListInsert (first, i, x) 在带头节点单链表first第 i 个元素结点前插入元素 x</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span> <span class="params">(LinkList first, ListData x, <span class="keyword">int</span> i )</span> </span>&#123;</span><br><span class="line">           <span class="comment">//在带头节点的单链表first中第 i 个元素结点前插入元素 x，成功返回1否则返回0</span></span><br><span class="line">  p = first;  k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( p &amp;&amp; k &lt; i <span class="number">-1</span> ) </span><br><span class="line">    &#123; p = p→next; k++; &#125;                        <span class="comment">//寻找第 i-1个结点</span></span><br><span class="line">  <span class="keyword">if</span> ( !p || i&lt;<span class="number">1</span>) ) &#123; </span><br><span class="line">    <span class="built_in">printf</span> ( “无效的插入位置!\n” );                  <span class="comment">//终止插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;                                        <span class="comment">//参数i值不合理返回0</span></span><br><span class="line">  newnode = (ListNode *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (ListNode) );    <span class="comment">//创建新结点</span></span><br><span class="line">  newnode→data = x; </span><br><span class="line">  newnode→next = p→next;                  <span class="comment">//插入新结点</span></span><br><span class="line">  p→next = newnode;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11、 ListDelete (first, i ) 删除带头节点单链表first的第 i 个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span> <span class="params">( LinkList first, <span class="keyword">int</span> i )</span> </span>&#123;</span><br><span class="line">         <span class="comment">//删除带头节点单链表first的第 i 个元素，成功返回1否则返回0</span></span><br><span class="line"> p=first; k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (p &amp;&amp; k++&lt;i<span class="number">-1</span>) p= p→next;  <span class="comment">//寻找第i-1个结点</span></span><br><span class="line">  <span class="keyword">if</span> ( !p ||!( p→next )|| i&lt;<span class="number">1</span>) </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;                     <span class="comment">//i值不合理或空表 </span></span><br><span class="line">   q = p→next;  </span><br><span class="line"> p→next = q→next;               <span class="comment">//删除结点</span></span><br><span class="line">  <span class="built_in">free</span> ( q );                    <span class="comment">//释放</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">createListF</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;<span class="comment">//创建带头结点单链表，函数返回</span></span><br><span class="line">                                    <span class="comment">//单链表的头指针</span></span><br><span class="line">  head =                    <span class="comment">//建立表头结点</span></span><br><span class="line">    (LinkList) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (ListNode));</span><br><span class="line">  head→next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( (ch = getchar( ) ) != ‘\n’ ) &#123;</span><br><span class="line">     q = (listNode *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">     q→data = ch;                      <span class="comment">//建立新结点</span></span><br><span class="line">    q→next = head→next;             <span class="comment">//插入到表前端</span></span><br><span class="line">     head→next = q;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">createListR</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;&#123;<span class="comment">//创建带头结点单链表，函数返回</span></span><br><span class="line">                                    <span class="comment">//单链表的头指针</span></span><br><span class="line">  head =(LinkList) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (ListNode));</span><br><span class="line">  r = head;                <span class="comment">//建立表头结点，r 指向表尾</span></span><br><span class="line"> <span class="keyword">while</span> ( (ch = getchar( ) ) != ‘\n’ ) &#123;</span><br><span class="line">    q = (listNode *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">     q→data = ch;                        <span class="comment">//建立新结点</span></span><br><span class="line">     r →next = q;  r =q;                  <span class="comment">//插入到表末端</span></span><br><span class="line">  &#125;</span><br><span class="line">  r →next = <span class="literal">NULL</span>;    <span class="keyword">return</span> head;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">100</span>;         <span class="comment">//静态链表大小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>            <span class="comment">//静态链表结点</span></span><br><span class="line">  ListData data; <span class="comment">// 数据域  </span></span><br><span class="line">  <span class="keyword">int</span> link; <span class="comment">// 游标域 书上是“cur”</span></span><br><span class="line">&#125; SNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>                 <span class="comment">//静态链表</span></span><br><span class="line">  SNode Nodes[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> newptr;                  <span class="comment">//当前可分配空间首地址</span></span><br><span class="line">&#125; SLinkList;</span><br></pre></td></tr></table></figure>

<p>1、InitList(&amp;Slink)；初始化带头结点静态链表Slink；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SLinkList &amp;Space，<span class="keyword">int</span> &amp;Slink)</span></span>&#123; </span><br><span class="line">                 <span class="comment">//初始化带头结点的静态链表Slink为空表</span></span><br><span class="line"><span class="keyword">if</span> (Space.newptr!=<span class="number">-1</span>)  </span><br><span class="line">&#123;Slink =Space.newptr;                  <span class="comment">//创建头结点 </span></span><br><span class="line"> Space.newptr= Space.Nodes[Space.newptr].link；&#125;</span><br><span class="line">                                  <span class="comment">//删除备用链表第一结点</span></span><br><span class="line"> Space.Nodes[Slink].link=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>2、DestroyList(&amp;Slink) 销毁带头节点静态链表Slink</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SLinkList &amp;Space，<span class="keyword">int</span> &amp;Slink)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//删去带头节点静态链表Slink所有结点，包括头结点</span></span><br><span class="line"> q =Slink；                  <span class="comment">//只需将销毁链插入到备用链表</span></span><br><span class="line"> <span class="keyword">while</span> (Space.Nodes[Slink].link!=<span class="number">-1</span>)      <span class="comment">//找链尾</span></span><br><span class="line"> Slink=Space.Nodes[Slink].link;</span><br><span class="line"> Space.Nodes[Slink].link=Space.newptr;<span class="comment">//链接链尾与备用链表表头</span></span><br><span class="line"> Space.newptr=q；        <span class="comment">//设置备用链表头指针为销毁链头指针</span></span><br><span class="line"> Slink=<span class="number">-1</span>；</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 3、 ClearList(Slink) 清空带头节点静态链表Slink</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SLinkList &amp;Space，<span class="keyword">int</span> Slink)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清空带头节点静态链表Slink，保留头结点</span></span><br><span class="line"> p = Space.Nodes[Slink].link；<span class="comment">//将清空链插入到备用链表</span></span><br><span class="line"> <span class="keyword">while</span> (Space.Nodes[p].link!=<span class="number">-1</span>)         <span class="comment">//找链尾</span></span><br><span class="line">   p=Space.Nodes[p].link;</span><br><span class="line"> Space.Nodes[p].link=Space.newptr；</span><br><span class="line">                    <span class="comment">//把链尾和备用链表表头相连</span></span><br><span class="line"> Space.newptr= Space.Nodes[Slink].link；         </span><br><span class="line">                           <span class="comment">//设置备用链表头指针</span></span><br><span class="line"> Space.Nodes[Slink].link=<span class="number">-1</span>;    <span class="comment">//设置空链表尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 4、 ListEmpty(Slink) 判断带头结点静态链表Slink是否为空，若为空返回1,否则返回0； </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListEmpty</span><span class="params">(SLinkList &amp;Space，<span class="keyword">int</span> Slink)</span> </span></span><br><span class="line"><span class="function"></span>&#123;          <span class="comment">//若带头结点静态链表Slink为空返回1,否则返回0</span></span><br><span class="line">    <span class="keyword">return</span> (Space.Nodes[Slink].link==<span class="number">-1</span>) ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、 ListLength (Slink) 求带头结点静态链表Slink的长度 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(SLinkList &amp;Space，<span class="keyword">int</span> Slink)</span> </span>&#123;</span><br><span class="line">             <span class="comment">//函数返回带头结点静态链表Slink长度</span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>; </span><br><span class="line">q=Slink；</span><br><span class="line"><span class="keyword">while</span> (Space.Nodes[q].link!=<span class="number">-1</span>)      <span class="comment">//在链上移动，计数</span></span><br><span class="line">  &#123;q=Space.Nodes[q].link; count++; &#125;</span><br><span class="line"><span class="keyword">return</span> count;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 6、 GetElem (Slink, i ) 函数值为带头结点静态链表Slink中第 i个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListData <span class="title">GetElem</span><span class="params">(SLinkList &amp;Space, <span class="keyword">int</span> Slink, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数返回带头结点静态链表Slink第i个元素值，不存在返回NULL</span></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>; q=Slink；</span><br><span class="line"><span class="keyword">while</span> (q!=<span class="number">-1</span>&amp;&amp; j&lt;i)      <span class="comment">//找第i个元素</span></span><br><span class="line"> &#123;q=Space.Nodes[q].link; j++; &#125;</span><br><span class="line"><span class="keyword">if</span> (p=<span class="number">-1</span>||j&gt;i) <span class="keyword">return</span> <span class="literal">NULL</span>;              <span class="comment">//第i个元素不存在</span></span><br><span class="line"><span class="keyword">return</span> Space.Nodes[q].data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7-1、LocateElem(SLink, x )  查找x在带头结点静态链表SLink中位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SLinkList &amp;Space, <span class="keyword">int</span> Slink, ListData x )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//在带头结点静态链表Slink中找值为x结点，找到返回x位置，否则返回-1</span></span><br><span class="line"> q=Space.Nodes[Slink].link；</span><br><span class="line"> <span class="keyword">while</span> (q!=<span class="number">-1</span>&amp;&amp; Space.Nodes[q].data!=x)      <span class="comment">//找X</span></span><br><span class="line">   q=Space.Nodes[q].link;</span><br><span class="line"> <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7-2、 IsIn(SLink, x ) 若x在带头结点静态链表Slink函数返回1否则返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsIn</span><span class="params">(SLinkList &amp;Space, <span class="keyword">int</span> Slink, ListData x )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//在带头结点静态链表Slink中找值为x结点，找到返回1否则返回0</span></span><br><span class="line"> q=Space.Nodes[Slink].link；</span><br><span class="line"> <span class="keyword">while</span> (q!=<span class="number">-1</span>&amp;&amp; Space.Nodes[q].data!=x)      <span class="comment">//找X</span></span><br><span class="line">   q=Space.Nodes[q].link;</span><br><span class="line"> <span class="keyword">return</span> !(q=<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、 NextElem (Slink, x ) 在带头结点静态链表Slink中求x的直接后继</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">NextElem</span><span class="params">(SLinkList &amp;Space, <span class="keyword">int</span> Slink, ListData x )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">////函数返回带头结点静态链表Slink中x的直接后继地址，没有返回-1</span></span><br><span class="line"> q=Space.Nodes[Slink].link；</span><br><span class="line"> <span class="keyword">while</span> (q!=<span class="number">-1</span>&amp;&amp; Space.Nodes[q].data!=x)      <span class="comment">//找X</span></span><br><span class="line">   q=Space.Nodes[q].link;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (q=<span class="number">-1</span> || Space.Nodes[q].link=<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//没有直接后继</span></span><br><span class="line"><span class="keyword">return</span> Space.Nodes[q].link;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9、PriorElem (Slink, x ) 在带头结点静态链表Slink中求x的直接前驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">NextElem</span><span class="params">(SLinkList &amp;Space, <span class="keyword">int</span> Slink, ListData x )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">////函数返回带头结点静态链表Slink中x的直接前驱地址，没有返回-1</span></span><br><span class="line"> q=Space.Nodes[Slink].link；</span><br><span class="line"> <span class="keyword">while</span> (q!=<span class="number">-1</span>&amp;&amp;Space.Nodes[q].link!=<span class="number">-1</span> &amp;&amp;Space.Nodes[Space.Nodes[q].link].data!=x)    <span class="comment">//找X</span></span><br><span class="line">   q=Space.Nodes[q].link;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">if</span> (q=<span class="number">-1</span> || Space.Nodes[q].link=<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//没有直接前驱</span></span><br><span class="line"><span class="keyword">return</span> q;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10、 ListInsert (Slink, i, x)  在带头节点静态链表Slink的第 i 个元素结点前插入 x</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">( SLinkList &amp;Space, <span class="keyword">int</span> Slink, <span class="keyword">int</span> i, ListData x )</span> </span>&#123;</span><br><span class="line">          <span class="comment">//在带头节点的静态链表Slink第 i 个结点前插入x，插入成功返回1否则返回0</span></span><br><span class="line"> <span class="keyword">int</span> j=<span class="number">0</span>; q=Slink；</span><br><span class="line"> <span class="keyword">while</span> (q!=<span class="number">-1</span>&amp;&amp; j&lt;i<span class="number">-1</span>)            <span class="comment">//找第i-1个元素</span></span><br><span class="line">   &#123;q=Space.Nodes[q].link; j++; &#125;</span><br><span class="line"> <span class="keyword">if</span> (q==<span class="number">-1</span>|| i&lt;<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;                            <span class="comment">//插入位置 i 错误</span></span><br><span class="line"> <span class="keyword">if</span> (Space.newptr!=<span class="number">-1</span>) &#123;p=Space.newptr;                    <span class="comment">//分配结点</span></span><br><span class="line">                     Space.newptr = Space.Nodes[Space.newptr].link;&#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>                             <span class="comment">//备用链表空</span></span><br><span class="line"> Space.Nodes[p].data = x;</span><br><span class="line"> Space.Nodes[p].link = Space.Nodes[q].link;</span><br><span class="line"> Space.Nodes[q].link = p;                       <span class="comment">//插入</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11、 ListDelete (Slink, i ) 删除带头节点静态链表Slink的第 i 个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">( SLinkList &amp;Space, <span class="keyword">int</span> Slink, <span class="keyword">int</span> i )</span> </span>&#123;</span><br><span class="line">  <span class="comment">//在带头结点的静态链表Slink删除第 i 个元素结点，删除成功返回1否则返回0</span></span><br><span class="line"> <span class="keyword">int</span> p =Slink;</span><br><span class="line"> <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (p!=<span class="number">-1</span>&amp;&amp;j++&lt;i<span class="number">-1</span>) p=Space.Nodes[p].link;</span><br><span class="line"> <span class="keyword">if</span> ( p ==<span class="number">-1</span>||Space.Nodes[p].link==<span class="number">-1</span> ||i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//找不到结点</span></span><br><span class="line"> <span class="keyword">int</span> q = Space.Nodes[p].link;           <span class="comment">//准备删除第 i个元素结点</span></span><br><span class="line"> Space.Nodes[p].link = Space.Nodes[q].link;</span><br><span class="line"> Space.Nodes[q].link = Space.newptr;   <span class="comment">//释放，链入备用链表表头</span></span><br><span class="line"> Space.newptr = q;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><ul>
<li>特点:最后一个结点的 link 指针不为NULL，而是指向第一个结点。只要已知表中某一结点的地址，就可搜寻所有结点的地址。</li>
<li>存储结构:链式存储结构</li>
<li> 单循环链表：在单链表中，将终端结点的指针域NULL改为指向表头结点的或开始结点，就得到了单链形式的循环链表，并简单称为单循环链表。    </li>
<li>为了使空表和非空表的处理一致，循环链表中也可设置一个头结点。这样，空循环链表仅有一个自成循环的头结点表示。</li>
</ul>
<h3 id="第二章作业三"><a href="#第二章作业三" class="headerlink" title="第二章作业三"></a>第二章作业三</h3><ul>
<li><p>1、 设计一个算法，将链表中所有结点的链接方向“原地”逆转，即要求仅利用原表的存储空间（也就是说，算法的空间复杂都为O(1)）。</p>
<p>所有源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> listData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  listData data;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;ListNode;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ListNode *LinkList;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(LinkList &amp;first)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  first =<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;first,listData x,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  LinkList p,newnode;</span><br><span class="line"></span><br><span class="line">  newnode=(ListNode* )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line"></span><br><span class="line">  newnode-&gt;data=x;</span><br><span class="line"></span><br><span class="line">  p= first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">​    newnode-&gt;next=p;</span><br><span class="line"></span><br><span class="line">​    first=newnode;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!p||i&lt;<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">  k=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(p&amp;&amp;k&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line"></span><br><span class="line">​    p=p-&gt;next;</span><br><span class="line"></span><br><span class="line">​    k++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p)&#123;</span><br><span class="line"></span><br><span class="line">  newnode-&gt;next=p-&gt;next;</span><br><span class="line"></span><br><span class="line">  p-&gt;next=newnode;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">free</span>(newnode);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Reverse</span><span class="params">(LinkList &amp;first)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  LinkList p,q,x;</span><br><span class="line"></span><br><span class="line">  p=first;</span><br><span class="line"></span><br><span class="line">  q=first;</span><br><span class="line"></span><br><span class="line">  x=first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(q)&#123;</span><br><span class="line"></span><br><span class="line">​    q=q-&gt;next;</span><br><span class="line"></span><br><span class="line">​    i++;  <span class="comment">//计算链表长度</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  q=first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span>(x-&gt;next)&#123;</span><br><span class="line"></span><br><span class="line">​      x=x-&gt;next; <span class="comment">//指向当前原顺序链表最后一个节点</span></span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(j==i)&#123;</span><br><span class="line"></span><br><span class="line">​      q=x;  <span class="comment">//用q指针记住原链表最后一个节点（翻转后的第一个节点）</span></span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">​      p=first; <span class="comment">//原链表表按原顺序只剩两个节点时候p指向第一个节点</span></span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">while</span>(p-&gt;next-&gt;next)&#123;</span><br><span class="line"></span><br><span class="line">​        p=p-&gt;next; <span class="comment">//指向x指向节点的前一个节点</span></span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  x-&gt;next=p; <span class="comment">//翻转过程 后一个节点的next指向前一个节点</span></span><br><span class="line"></span><br><span class="line">  p-&gt;next=<span class="literal">NULL</span>; <span class="comment">//把前一个节点的next先断掉 原链表长度-1</span></span><br><span class="line"></span><br><span class="line">  x=first; <span class="comment">//x，q回到初始节点重新遍历</span></span><br><span class="line"></span><br><span class="line">  p=first;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  first=q;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ShowList</span><span class="params">(LinkList first)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  LinkList p=first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  i=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(p)&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">&quot;a[%d]=%d\n&quot;</span>,i,p-&gt;data);</span><br><span class="line"></span><br><span class="line">​    p=p-&gt;next;</span><br><span class="line"></span><br><span class="line">​    i++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  LinkList L;</span><br><span class="line"></span><br><span class="line">  InitList(L);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">​    ListInsert(L, i*<span class="number">10</span>, i);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ShowList(L);</span><br><span class="line"></span><br><span class="line">  Reverse(L);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;翻转后\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ShowList(L);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>实现结果 完成翻转</p>
<p>​                               </p>
<p>2、定义静态链表的存储结构；写出不带头结点静态链表的插入和删除算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  ElemType data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> cur;</span><br><span class="line"></span><br><span class="line">&#125; StaticLinkList[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//在备用表中找到并返回第一个元素的下标，并改变数组[0]的cur</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SL</span><span class="params">(StaticLinkList space)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = space[<span class="number">0</span>].cur;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (space[<span class="number">0</span>]. cur)</span><br><span class="line"></span><br><span class="line">​    space[<span class="number">0</span>]. cur = space[i].cur;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取使用链表的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i=L[MAXSIZE<span class="number">-1</span>].cur;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(i)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    i=L[i].cur;</span><br><span class="line"></span><br><span class="line">​    j++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">ListInsert</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i, ElemType x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> j, k, l;</span><br><span class="line"></span><br><span class="line">  k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否超范围</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回备用表第一个元素的下标</span></span><br><span class="line"></span><br><span class="line">  j = Malloc_SL(L);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (j)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    L[j].data = x;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//找到i前面的元素下标k</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span>(l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++)</span><br><span class="line"></span><br><span class="line">​      k = L[k].cur;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//j继承k的cur</span></span><br><span class="line"></span><br><span class="line">​    L[j].cur = L[k].cur;</span><br><span class="line"></span><br><span class="line">​    L[k].cur = j;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SL</span><span class="params">(StaticLinkList space, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  space[i].cur = space[<span class="number">0</span>].cur;</span><br><span class="line"></span><br><span class="line">  space[<span class="number">0</span>].cur = i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">ListDelete</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> j, k;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L))</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line"></span><br><span class="line">​    k = L[k].cur;</span><br><span class="line"></span><br><span class="line">  j = L[k].cur;</span><br><span class="line"></span><br><span class="line">  L[k].cur = L[j].cur;</span><br><span class="line"></span><br><span class="line">  Free_SL(L, j);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、已知一个带有表头结点的单链表，结点结构为(data，ink)，假设该链表只给出了头指针first。在不改变链表的前提下，请设计一个尽可能高效的算法，査找链表中倒数第k个位置上的结点(k为正整数)。若查找成功，算法输出该结点的data域的值，并返回1。（1）描述算法基本设计思想；（2）描述算法实现步骤；（3）采用程序设计语言描述算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchK</span><span class="params">(LinkList &amp;<span class="built_in">list</span>,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查找链表list倒数第k个结点，并输出该结点data域的值</span></span><br><span class="line"></span><br><span class="line">  LinkList p,q;</span><br><span class="line"></span><br><span class="line">  p=<span class="built_in">list</span>-&gt;next;</span><br><span class="line"></span><br><span class="line">  q=<span class="built_in">list</span>-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//计数器初始化为0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(p)&#123;<span class="comment">//指针p依次遍历链表直至最后一个结点</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(count&lt;k)&#123;</span><br><span class="line"></span><br><span class="line">​      count++;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">​      q=q-&gt;next;&#125;</span><br><span class="line"></span><br><span class="line">​      p=p-&gt;next;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(count&lt;k)&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> q-&gt;data;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ul>
<li>​     和单链表类似，双链表一般也是由头指针唯一确定的，增加头指针也能使双链表上的某些运算变得方便，将头结点和尾结点链接起来也能构成循环链表，并称之为双向链表。</li>
<li>设指针p指向某一结点，则双向链表结构的对称性可用下式描述：</li>
<li>(p—&gt;prior)—&gt;next=p=(p—&gt;next)—&gt;prior</li>
<li> 即结点<em>p的存储位置既存放在其前趋结点</em>(p—&gt;prior)的直接后继指针域中，也存放 在它的后继结点*(p—&gt;next)的直接前趋指针域中。</li>
<li>双向链表优点：访问、插入、删除更方便、速度更快。</li>
<li>不足：以空间换时间</li>
</ul>
<h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ListData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dnode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  ListData data;             </span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dnode</span> * <span class="title">prior</span>, * <span class="title">next</span>;</span>   </span><br><span class="line"></span><br><span class="line">&#125; DblNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> DblNode * DblList;     </span><br></pre></td></tr></table></figure>

<p>初始化双向循环链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">( DblList  &amp;first )</span> </span>&#123;</span><br><span class="line">                  <span class="comment">//初始化带头结点的双向循环链表first</span></span><br><span class="line">  first = ( DblNode*) <span class="built_in">malloc</span> ( <span class="keyword">sizeof</span> ( DblNode ) );</span><br><span class="line">  <span class="keyword">if</span> ( !first )</span><br><span class="line">    &#123; print ( “存储分配错!\n” ); <span class="built_in">exit</span> (<span class="number">1</span>); &#125;</span><br><span class="line">  first→prior = first→next = first;</span><br><span class="line">                       <span class="comment">//表头结点的链指针指向自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求双向循环链表长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span> <span class="params">( DblList first )</span> </span>&#123;</span><br><span class="line">             <span class="comment">//计算带头结点的双向循环链表的长度</span></span><br><span class="line">  DblNode * p = first→next;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( p != first ) </span><br><span class="line">     &#123; p = p→next; count++; &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span> <span class="params">( DblList first, <span class="keyword">int</span> i, ListData x )</span> </span>&#123;</span><br><span class="line">   <span class="comment">//在带头结点的双向循环链表first的第i个结点前插入x</span></span><br><span class="line">   DblNode * p = LocateElem ( first, i<span class="number">-1</span> );  </span><br><span class="line">                         <span class="comment">//指针定位于插入位置</span></span><br><span class="line">   <span class="keyword">if</span> ( p == first &amp;&amp; i != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   DblNode * q = ( DblNode * ) <span class="built_in">malloc</span></span><br><span class="line">      ( <span class="keyword">sizeof</span> ( DblNode ) );          <span class="comment">//分配结点</span></span><br><span class="line">   q→data = x;</span><br><span class="line">   q→prior = p;  q→next = p→next;</span><br><span class="line">   p→next = q; q→next→prior = q; </span><br><span class="line">                                 <span class="comment">//链入新结点</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">( DblList first, <span class="keyword">int</span> i )</span> </span>&#123;</span><br><span class="line">           <span class="comment">//在带头结点的双向循环链表first的删除第i个结点</span></span><br><span class="line">   DblNode * p = LocateElme( first, i );  </span><br><span class="line">                         <span class="comment">//指针定位于删除结点位置</span></span><br><span class="line">   <span class="keyword">if</span> ( p == first ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   p→next→prior = p→prior;</span><br><span class="line">   p→prior→next = p→next;       <span class="comment">//删除结点 p</span></span><br><span class="line">   <span class="built_in">free</span> ( p );                      <span class="comment">//释放</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二章作业四"><a href="#第二章作业四" class="headerlink" title="第二章作业四"></a>第二章作业四</h3><p>1、 分别在带头结点的双链表中的第一个值为x的结点之前、之后插入元素值为y的结点，分别编写各自的算法。</p>
<p>之前插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">y_insert</span><span class="params">(Dlinklist **head, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  linklist L = (*head) -&gt; next, p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(L &amp;&amp; L -&gt; data != x) </span><br><span class="line"></span><br><span class="line">​    L = L -&gt; next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!L)     </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    p = (linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Dlinklist));     </span><br><span class="line"></span><br><span class="line">​    p -&gt; data = y;       </span><br><span class="line"></span><br><span class="line">​    L -&gt; prior -&gt; next = p;   </span><br><span class="line"></span><br><span class="line">​    p -&gt; prior = L -&gt; prior;</span><br><span class="line"></span><br><span class="line">​    L -&gt; prior = p;</span><br><span class="line"></span><br><span class="line">​    p -&gt; next = L;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">y_afterinsert</span><span class="params">(Dlinklist **head, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  linklist L = (*head) -&gt; next, p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(L &amp;&amp; L -&gt; data != x) </span><br><span class="line"></span><br><span class="line">​    L = L -&gt; next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!L)     </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    p-&gt;next = L-&gt;next;</span><br><span class="line"></span><br><span class="line">​    p-&gt;prior = L;</span><br><span class="line"></span><br><span class="line">​    L-&gt;next-&gt;prior = p;</span><br><span class="line"></span><br><span class="line">​    L-&gt;next = p;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、有一个双链表L，其中有n(n&gt;=1)个值不相同的数据节点，设计一个算法删除最大值的结点。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(DLinkList &amp;dlLink, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  DLinkList p = dlLink;</span><br><span class="line"></span><br><span class="line">  DLinkList deleteNode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    max = p-&gt;data;</span><br><span class="line"></span><br><span class="line">​    p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (p-&gt;data &gt; max)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      max = p-&gt;data;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p = dlLink;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (p-&gt;data == max)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  deleteNode = p-&gt;next;</span><br><span class="line"></span><br><span class="line">  deleteNode-&gt;next-&gt;prev = p;</span><br><span class="line"></span><br><span class="line">  p-&gt;next = deleteNode-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(deleteNode);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三章-栈与递归"><a href="#第三章-栈与递归" class="headerlink" title="第三章 栈与递归"></a>第三章 栈与递归</h2><ul>
<li><h2 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h2></li>
<li><h2 id="若一个对象部分地包含它自己-或用它自己给自己定义-则称这个对象是递归的；若一个过程直接地或间接地调用自己-则称这个过程是递归的过程。"><a href="#若一个对象部分地包含它自己-或用它自己给自己定义-则称这个对象是递归的；若一个过程直接地或间接地调用自己-则称这个过程是递归的过程。" class="headerlink" title="若一个对象部分地包含它自己, 或用它自己给自己定义, 则称这个对象是递归的；若一个过程直接地或间接地调用自己, 则称这个过程是递归的过程。"></a>若一个对象部分地包含它自己, 或用它自己给自己定义, 则称这个对象是递归的；若一个过程直接地或间接地调用自己, 则称这个过程是递归的过程。</h2></li>
<li><p>n<strong>以下三种情况常常用到递归方法</strong></p>
<p>Ø<strong>递归定义的数学函数</strong></p>
<p>Ø<strong>具有递归特性的数据结构</strong></p>
<p>Ø<strong>可递归求解的问题</strong></p>
</li>
<li><p>分治法</p>
<ul>
<li><p>对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解</p>
</li>
<li><p><strong>必备的三个条件</strong></p>
<ul>
<li><p>1、能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是变化有规律的</p>
<p>2、可以通过上述转化而使问题简化</p>
<p>3、必须有一个明确的递归出口，或称递归的边界</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>递归的优缺点</p>
<ul>
<li>优点：结构清晰，程序易读</li>
<li>缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。</li>
</ul>
</li>
</ul>
<ol>
<li>栈</li>
</ol>
<ul>
<li>§定义:是限定仅在表尾进行插入或删除操作的线性表。</li>
<li>§允许插入和删除的一端</li>
<li> 称为栈顶(top)，另一端</li>
<li> 称为栈底(bottom)</li>
<li>§特点:后进先出(先进后出)</li>
</ul>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>§顺序栈：栈的顺序存储结构，利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，</p>
<p> 指针top指向栈顶元素在顺序栈中的下一个位置，</p>
<p> 指针base为栈底指针，指向栈底的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100；<span class="comment">//存储空间初始分配量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT 10；<span class="comment">//存储空间分配的增量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">//顺序栈定义</span></span><br><span class="line"> SElemType *base; <span class="comment">//栈底指针 </span></span><br><span class="line"> SElemType *top;  <span class="comment">//栈顶指针 </span></span><br><span class="line"> <span class="keyword">int</span> stacksize； <span class="comment">//当前已分配的存储空间</span></span><br><span class="line">&#125; SqStack；</span><br></pre></td></tr></table></figure>

<p>•初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span> <span class="params">( SqStack &amp;S)</span> </span>&#123;  <span class="comment">//建空栈</span></span><br><span class="line"></span><br><span class="line"> S.base =( SElemType *) <span class="built_in">malloc</span>(STACK_INIT_SIZE *  <span class="keyword">sizeof</span>(SElemType));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!S.base) <span class="built_in">exit</span>(OVERFLOW);  <span class="comment">//存储分配失败</span></span><br><span class="line"></span><br><span class="line"> S.top = S.base ; </span><br><span class="line"></span><br><span class="line"> S.Stacksize = STACK_INIT_SIZE ;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>§判栈空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span> <span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( S.top == S.base ) <span class="keyword">return</span> TRUE; <span class="comment">//栈空</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> FALSE; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>§判栈满</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackFull</span> <span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>( S.top - S.base &gt;= S.StackSize )    <span class="comment">//栈满</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TRUE; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求栈的长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">( SqStack S )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> S.top – S.base;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清空顺序栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">( SqStack S )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>( S.base ) S.top = S.base;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>销毁顺序栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">( SqStack &amp;S )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>( S.base )</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">delete</span> S.base ;</span><br><span class="line"></span><br><span class="line"> S.stacksize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> S.base = S.top = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§入栈(进栈)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span> <span class="params">(SqStack &amp;S, SElemType e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素e为新的栈顶元素</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( StackFull (S) )&#123; <span class="comment">//栈满，追加存储空间</span></span><br><span class="line"></span><br><span class="line"> S.base = ( SElemType *)<span class="built_in">malloc</span>(S.base ,</span><br><span class="line"></span><br><span class="line">   (S.stacksize + STACKINCREMENT) *    <span class="keyword">sizeof</span>(SElemType));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(! S.base) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">  S.top = S.base + S.stacksize;</span><br><span class="line"></span><br><span class="line"> S.stacksize += STACKINCREMENT; </span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> *(S.top++) = e;</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺序栈出栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">( SqStack &amp;S, SElemType &amp;e)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//若栈空返回ERROR, 否则删除栈顶元素，用e返回其值.</span></span><br><span class="line">	<span class="keyword">if</span>( S.top == S.base ) <span class="comment">// 栈空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR; 	</span><br><span class="line">	e＝ *--S.top;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取顺序栈栈顶元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">( SqStack S, SElemType &amp;e)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//若栈空返回ERROR, 否则栈顶元素读到e并返回OK</span></span><br><span class="line">	<span class="keyword">if</span>( S.top == S.base )	 <span class="keyword">return</span> ERROR; 	<span class="comment">// 栈空</span></span><br><span class="line">	e = *( S.top – <span class="number">1</span> );</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态顺序栈"><a href="#静态顺序栈" class="headerlink" title="静态顺序栈"></a>静态顺序栈</h3><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    SElemType data;	       <span class="comment">//结点	</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>	       <span class="comment">//链指针</span></span><br><span class="line">&#125; StackNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    StackNode *top;           <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; LinkStack;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol>
<li><p>队列</p>
<ol>
<li>基本概念</li>
<li>定义:只允许在表的一端进行插入，而在另一端删除元素的线性表。也是一种运算受限的线性表。</li>
<li>  在队列中，允许插入的一端叫队尾(rear)，</li>
<li>允许删除的一端称为队头(front)。</li>
<li>先进先出</li>
</ol>
</li>
<li><p>队列、栈和线性表的区别与联系</p>
<ol>
<li><p>栈和队列都是线性表，都是限制了插入删除点的线性表（或者说是控制了访问点的线性表）</p>
<p>区别：栈只允许在一端进行插入或删除操作的线性表，其最大的特点是“后进后出”；队列是只允许在一端进行插入，另一端进行删除操作的线性表，其最大的特点是“先进后出”；一般的线性表允许在表中任意位置进行插入或删除操作。</p>
<p>联系（共同点）：n个（同类）数据元素的有限序列称为线性表。线性表的特点是数据元素之间存在“一对一”的关系，栈和队列都是操作受限制的线性表，他们和线性表一样，数据元素之间都存在“一对一”的关系。栈和队列都是只能在线性表的端点插入和删除。</p>
</li>
</ol>
</li>
</ol>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100   <span class="comment">//最大长度</span></span></span><br><span class="line"></span><br><span class="line">Typedef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"></span><br><span class="line"> QElemType *data; <span class="comment">//初始化的动态分配存储空间</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> front; <span class="comment">//头指针 </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> rear; <span class="comment">//尾指针</span></span><br><span class="line"></span><br><span class="line">&#125; SqQueue</span><br></pre></td></tr></table></figure>

<p>§初始化队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span> <span class="params">( SqQueue &amp;Q )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造空队列</span></span><br><span class="line"></span><br><span class="line"> Q.data=(QueueData *)<span class="built_in">malloc</span>(MAXSIZE  *<span class="keyword">sizeof</span>(QueueData));</span><br><span class="line"></span><br><span class="line"> If(! Q.data)  <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line"> Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> ok</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求循环队列的长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span> <span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (Q.rear-Q.front+Maxsize)%Maxsize;               </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>1） Q.rear&gt;=Q.front, 那么Q.rear-Q.front。</p>
<p>2） Q.rear &lt; Q.front, 那么Q.rear-Q.front+Maxsize</p>
<p>统一为： (Q.rear-Q.front+Maxsize)%Maxsize。</p>
<p>ü当Q.rear-Q.front为正数时，加上Maxsize就超过了最大空间数，取余后就正好是元素个数；</p>
<p>ü当Q.rear-Q.front为负数时，加上Maxsize就正好是元素个数，由于小于Maxsize，故取余运算对其没有影响。</p>
<p>所以， %Maxsize是为了防止Q.rear-Q.front为正数的情况，+Maxsize为了防止Q.rear-Q.front为负数的情况。</p>
<p>§判队空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span> <span class="params">( SqQueue &amp;Q )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Q.rear == Q.front;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§判队满</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueFull</span> <span class="params">( SqQueue &amp;Q )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (Q.rear+<span class="number">1</span>) % QueueSize == Q.front;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§入队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span> <span class="params">( SqQueue &amp;Q, QElemType e )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( QueueFull (Q) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  Q.data[Q.rear] = e;</span><br><span class="line">  Q.rear = ( Q.rear+<span class="number">1</span>) % MAXSIZE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§出队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span> <span class="params">( SqQueue &amp;Q, QElemType &amp;e )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( QueueEmpty (Q) ) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">  e = Q.data[Q.front]; </span><br><span class="line"></span><br><span class="line"> Q.front = ( Q.front+<span class="number">1</span>) % MAXSIZE;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§取队头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFront</span> <span class="params">( SqQueue &amp;Q, QElemtype &amp;e )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ( QueueEmpty (Q) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   e = Q.data[(Q.front+<span class="number">1</span>) % MAXSIZE];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h3><p>链式队列的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span> </span><br><span class="line"></span><br><span class="line">  QElemType   data;  <span class="comment">//队列结点数据</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span> <span class="comment">//结点链指针</span></span><br><span class="line"></span><br><span class="line">&#125; QNode, *QueuePtr;   <span class="comment">//链队数据结点类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  QueuePtr  front;   <span class="comment">//队头指针</span></span><br><span class="line"></span><br><span class="line">  QueuePtr  rear;   <span class="comment">//队尾指针</span></span><br><span class="line"></span><br><span class="line">&#125; LinkQueue;  <span class="comment">//链队结点类型</span></span><br></pre></td></tr></table></figure>

<p>§初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">Status <span class="title">InitQueue</span> <span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  Q.front=Q.rear=(QueuePtr) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode)); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">  Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>销毁链队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyQueue</span> <span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(Q.front)&#123;</span><br><span class="line"></span><br><span class="line">   Q.rear=Q.front-&gt;next;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(Q.front);</span><br><span class="line"></span><br><span class="line">   Q.front=Q.rear;  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§判断队空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span> <span class="params">( LinkQueue &amp;Q )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Q.front == <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//当Q.front==NULL且Q.rear=NULL时，链式队列为空</p>
<p>§取队头元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFront</span> <span class="params">( LinkQueue &amp;Q, QueueData &amp;e )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( QueueEmpty (Q) ) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">  e = Q.front-&gt;data; <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§入队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素e为Q的新的队尾结点</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(QueuePtr Q, QElemType e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  QueuePtr q = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!q) &#123;        <span class="comment">//存储分配失败</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  q-&gt;data = e;</span><br><span class="line"></span><br><span class="line">  q-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">  Q-&gt;rear-&gt;next = q; <span class="comment">//先使rear指向结点的next指向新节点q</span></span><br><span class="line"></span><br><span class="line">  Q-&gt;rear = q;     <span class="comment">//再使尾指针指向q</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>§出队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span> <span class="params">( LinkQueue &amp;Q, QueueData &amp;e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删去队头结点，并返回队头元素的值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( QueueEmpty (Q) ) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//判队空</span></span><br><span class="line"></span><br><span class="line">  QueueNode *p = Q.front; </span><br><span class="line"></span><br><span class="line">  e = p-&gt;data; <span class="comment">//保存队头的值</span></span><br><span class="line"></span><br><span class="line">  Q.front= Q.front-&gt;next;  <span class="comment">//新队头</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (Q.rear == p)   Q.rear = Q.front;  <span class="comment">//对队尾指针重新赋值（指向头 结点）</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">free</span> (p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环队列与链队列的比较</p>
<p>从时间上考虑，循环队列和链队列的基本操作都是O(1),不过循环队列是事先已申请好空间，使用期间不会释放。而对于链队列，每次申请和释放结点也会存在一些时间开销。如果入队和出队频繁，两者还是有细微差异的。<br> 　从空间来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但是是可以接受的。所以从空间上说，链队列更加灵活。<br> 　总的来说，在可以确定链队列最大长度的情况下，建议使用循环队列。如果无法预估队列的长度，则使用链队列。</p>
<p>Ø循环队列要事先申请好空间，整个过程都不能释放，而且要有固定的长度，如果长度事先无法估计，这种方式显然不够灵活；</p>
<p>Ø所以就引入了链式存储队列，其实就是线性表的单链表，只是它只能对尾进，队头出。并且规定队头指针指向链队列的头结点，对尾指针指向终端节点，当队列为空时，front和rear都指向头结点。入队操作，就是在链表尾部插入结点；出队操作就是头结点的后继结点出队，然后将头结点的后继后移。如果最后除了头结点外，只剩一个元素了，就把rear也指向头结点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" data-id="ckomi7m4w000bo6514nq745kj" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-React" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/React/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T18:14:44.898Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/React/" data-id="ckomi7m4d0001o651fgkd7pth" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Vue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/Vue/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T18:13:49.269Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="Npm"><a href="#Npm" class="headerlink" title="Npm"></a>Npm</h2><p>(Node package Manager)</p>
<p>是node.js 默认的，以js编写的软件包管理系统</p>
<p><a target="_blank" rel="noopener" href="http://npmjs.com/">http://npmjs.com</a></p>
<ul>
<li><p>包管理器</p>
</li>
<li><p>使用过程</p>
</li>
<li><p>npm init –yes</p>
</li>
<li><p>npm install jquery -save //运行时依赖</p>
</li>
<li><p>npm install bootstrap -save-dev //安装时依赖 运行时渲染完成后删除</p>
</li>
<li><p>拷贝项目时候不发扩展包</p>
</li>
<li><p>拿到时候直接用 npm install 所有软件包的记录都会还原</p>
</li>
<li><p>删去^3.5.1 的^会一直以这个版本</p>
</li>
<li><p>^保留 则表示大版本不变，小版本会进行更新 ^3.x.x</p>
</li>
<li><p>~表示 ~3.5.x 只更新最后一位</p>
</li>
</ul>
<h2 id="ES6兼容性解决"><a href="#ES6兼容性解决" class="headerlink" title="ES6兼容性解决"></a>ES6兼容性解决</h2><p>兼容低版本浏览器</p>
<ul>
<li>在线转换(这种编译会加大页面渲染的时间)</li>
<li>提前编译(强烈建议这种方式，不影响浏览器渲染时间)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/Vue/" data-id="ckomi7m4g0003o6513z3f7kq9" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-HtmlCss基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/HtmlCss%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T18:13:38.886Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Htmlcss基础"><a href="#Htmlcss基础" class="headerlink" title="Htmlcss基础"></a>Htmlcss基础</h1><h2 id="1-Html基础"><a href="#1-Html基础" class="headerlink" title="1.Html基础"></a>1.Html基础</h2><h3 id="table表格"><a href="#table表格" class="headerlink" title="table表格"></a>table表格</h3><ul>
<li>表格 不是布局页面 而是展示数据</li>
<li>表格相关属性    cellspacing    cellpadding     width  height  border </li>
<li>合并单元格 rowspan   collspan</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>列表</p>
<p>略</p>
</li>
<li><p>表单</p>
</li>
</ul>
<h3 id="input表单控件"><a href="#input表单控件" class="headerlink" title="input表单控件"></a>input表单控件</h3><ul>
<li><p>type值：</p>
</li>
<li><p>button</p>
</li>
<li><p>checkbox</p>
</li>
<li><p>file</p>
</li>
<li><p>hidden 定义隐藏字段</p>
</li>
<li><p>image 图像形式提交按钮</p>
</li>
<li><p>password</p>
</li>
<li><p>radio 单选按钮</p>
</li>
<li><p>reset 重置按钮 清除表单数据</p>
</li>
<li><p>subimt</p>
</li>
<li><p>text 单行输入字段</p>
</li>
<li><p>name 定义input名称</p>
</li>
<li><p>value 规定input元素值</p>
</li>
<li><p>checked 首次加载时被选中</p>
</li>
<li><p>maxlength 规定输入字段字符最大长度</p>
</li>
<li><p>lable标签</p>
</li>
<li><p>```html<br><label> 标签为 input 元素定义标注（标签）。<br><label> 标签用于绑定一个表单元素, 当点击<label> 标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上,用来增加用户体验.<br>语法：</p>
<pre><code> &lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;
&lt;input type=&quot;radio&quot; name=&quot;sex&quot;  id=&quot;sex&quot; /&gt;
核心： &lt;label&gt; 标签的 for 属性应当与相关元素的 id 属性相同。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Select option textarea</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  &lt;form&gt;</span><br><span class="line">  		&lt;input type=“text&quot; name=“username&quot;&gt;</span><br><span class="line">  		&lt;select name=&quot;jiguan&quot;&gt;  </span><br><span class="line">  		 &lt;option&gt;北京&lt;/option&gt;</span><br><span class="line">  		&lt;/select&gt; </span><br><span class="line">  		&lt;textarea name= &quot;message&quot;&gt;</span><br><span class="line">  	&lt;/textarea&gt;                    &lt;/form&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>小结</p>
</li>
<li><p>有三个名字非常相似的标签:表单域   form    使用场景:  提交区域内表单元素给后台服务器文件域   file </p>
</li>
<li><p> 是input type 属性值   使用场景: 上传文件文本域   </p>
</li>
<li><p>textarea    使用场景:  可以输入多行文字, 比如留言板  网站介绍等…</p>
</li>
<li><p> 我们当前阶段不需要提交表单元素,所以我们只负责表单元素的外观形态即可.</p>
</li>
<li><p>文档网址</p>
</li>
</ul>
<h2 id="2-css基础"><a href="#2-css基础" class="headerlink" title="2.css基础"></a>2.css基础</h2><h3 id="css显示模式"><a href="#css显示模式" class="headerlink" title="css显示模式"></a>css显示模式</h3><ul>
<li><p>(1)display:inline;转换为行内元素</p>
<p>(2)display:block;转换为块状元素</p>
<p>(3)display:inline-block;转换为行内块状元素</p>
</li>
</ul>
<h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/b">b</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/big">big</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/i">i</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/small">small</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/tt">tt</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/abbr">abbr</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/acronym">acronym</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/cite">cite</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/code">code</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/dfn">dfn</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/em">em</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/kbd">kbd</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/strong">strong</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/samp">samp</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/var">var</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a">a</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/bdo">bdo</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/br">br</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img">img</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/map">map</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object">object</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/q">q</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script">script</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/span">span</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/sub">sub</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/sup">sup</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button">button</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input">input</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/label">label</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/select">select</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/textarea">textarea</a></p>
</li>
<li><p>行内元素最常使用的就是span，其他的只在特定功能下使用，修饰字体<b>和<i>标签，还有<sub>和<sup>这两个标签可以直接做出平方的效果，而不需要类似移动属性的帮助，很实用。</p>
</li>
<li><p>行内元素特征：</p>
</li>
<li><p>(1)设置宽高无效</p>
<p>(2)对margin仅设置左右方向有效，上下无效；padding设置上下左右都有效，即会撑大空间</p>
<p>(3)不会自动进行换行</p>
</li>
<li><p>行内元素与块级元素对比</p>
<ul>
<li><p>内容</p>
<p>一般情况下，行内元素只能包含数据和其他行内元素。</p>
<p>而块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。</p>
</li>
<li><p>格式</p>
<p>默认情况下，行内元素不会以新行开始，而块级元素会新起一行。</p>
</li>
</ul>
</li>
</ul>
<h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><ul>
<li><p>HTML（超文本标记语言）中元素大多数都是“块级”元素或<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements">行内元素 (en-US)</a>。块级元素占据其父元素（容器）的整个空间，因此创建了一个“块”。这篇文章帮助解释这个概念。</p>
<p>通常浏览器会在块级元素前后另起一个新行。下面的例子表明了块级元素的作用：</p>
</li>
<li><p>以下是 HTML 中所有的块级元素列表（虽然”块级“在新的 HTML5 元素中没有明确定义）</p>
</li>
<li><p>　块状元素代表性的就是div，其他如p、nav、aside、header、footer、section、article、ul-li、address等等，都可以用div来实现。不过为了可以方便程序员解读代码，一般都会使用特定的语义化标签，使得代码可读性强，且便于查错</p>
</li>
<li><p>块状元素特征：</p>
</li>
<li><p>(1)能够识别宽高</p>
<p>(2)margin和padding的上下左右均对其有效</p>
<p>(3)可以自动换行</p>
<p>(4)多个块状元素标签写在一起，默认排列方式为从上至下</p>
</li>
</ul>
<h4 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h4><ul>
<li><p><img />、<input />、<td></p>
</li>
<li><p>　行内块状元素综合了行内元素和块状元素的特性，但是各有取舍。因此行内块状元素在日常的使用中，由于其特性，使用的次数也比较多。</p>
</li>
<li><p>行内块状元素特征：</p>
<p>(1)不自动换行</p>
<p>(2)能够识别宽高</p>
<p>(3)默认排列方式为从左到右</p>
</li>
</ul>
<p>单行文字垂直居中的代码</p>
<p><strong>解决方案</strong>:    </p>
<p>​        让文字的行高等于盒子的高度  就可以让文字在当前盒子内垂直居中</p>
<p><strong>简单理解</strong>: </p>
<p>​        行高的上空隙和下空隙把文字挤到中间了，</p>
<p>​        如果行高小于盒子高度,文字会偏上，</p>
<p>​        如果行高大于盒子高度,则文字偏下。</p>
<h3 id="css复合选择器"><a href="#css复合选择器" class="headerlink" title="css复合选择器"></a>css复合选择器</h3><h4 id="后代选择器ul-li"><a href="#后代选择器ul-li" class="headerlink" title="后代选择器ul li { }"></a>后代选择器ul li { }</h4><h4 id="子选择器div-gt-p"><a href="#子选择器div-gt-p" class="headerlink" title="子选择器div &gt; p { }"></a>子选择器div &gt; p { }</h4><p>div最近一级p标签</p>
<h4 id="并集选择器ul-div"><a href="#并集选择器ul-div" class="headerlink" title="并集选择器ul ,div {}"></a>并集选择器ul ,div {}</h4><h4 id="伪类选择器-hover-first-child"><a href="#伪类选择器-hover-first-child" class="headerlink" title="伪类选择器:hover :first-child"></a>伪类选择器:hover :first-child</h4><h4 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:link	没有点击过的(访问过的)链接</span><br><span class="line">a:visited	点击过的(访问过的)链接</span><br><span class="line">a:hover	鼠标经过的那个链接</span><br><span class="line">a:active	鼠标正在按下还没有弹起鼠标的那个链接</span><br></pre></td></tr></table></figure>

<p><strong>链接伪类选择器注意事项</strong></p>
<p>为了确保生效，请按照 LVHA 的循顺序声明 :link－:visited－:hover－:active。</p>
<p>记忆法：love hate 或者 lv 包包 hao 。</p>
<p>因为 a 链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式。</p>
<h4 id="focus-伪类选择器"><a href="#focus-伪类选择器" class="headerlink" title="focus:伪类选择器"></a>focus:伪类选择器</h4><p><strong>定义：</strong></p>
<p>​        :focus 伪类选择器用于选取获得焦点的表单元素。</p>
<p>​        焦点就是光标，一般情况 <input> 类表单元素才能获取</p>
<h3 id="css背景"><a href="#css背景" class="headerlink" title="css背景"></a>css背景</h3><h4 id="1-background-color-transparent"><a href="#1-background-color-transparent" class="headerlink" title="1.background-color :transparent"></a>1.background-color :transparent</h4><h4 id="2-background-image-url-src"><a href="#2-background-image-url-src" class="headerlink" title="2.background-image:url(src)"></a>2.background-image:url(src)</h4><h4 id="3-background-repeat-repeat-no-repeat-repeat-x-repeat-y"><a href="#3-background-repeat-repeat-no-repeat-repeat-x-repeat-y" class="headerlink" title="3. background-repeat: repeat|no-repeat|repeat-x|repeat-y"></a>3. background-repeat: repeat|no-repeat|repeat-x|repeat-y</h4><h4 id="4-background-position-x-y"><a href="#4-background-position-x-y" class="headerlink" title="4. background-position:x y;"></a>4. background-position:x y;</h4><ul>
<li><p>其他说明</p>
<p>1、参数是方位名词</p>
<p>​        如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left  top 和 top  left 效果一致</p>
<p>​        如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐</p>
<p>2、参数是精确单位</p>
<p>​        如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是 y 坐标</p>
<p>​        如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中</p>
<p>3、参数是混合单位</p>
<p>​        如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标</p>
</li>
<li><p>背景图片固定</p>
</li>
</ul>
<h4 id="5-background-attachment-scroll-fixed"><a href="#5-background-attachment-scroll-fixed" class="headerlink" title="5.background-attachment: scroll | fixed"></a>5.background-attachment: scroll | fixed</h4><ul>
<li><p> 属性设置背景图像是否固定或者随着页面的其余部分滚动。</p>
</li>
<li><p><strong>其他说明：</strong></p>
<p>​        background-attachment 后期可以制作视差滚动的效果。</p>
</li>
<li><p>背景样式合写</p>
</li>
<li><p>background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置;</p>
</li>
<li><p>背景色半透明</p>
</li>
</ul>
<h4 id="6-background-rgba-0-0-0-3"><a href="#6-background-rgba-0-0-0-3" class="headerlink" title="6.background:rgba(0,0,0,.3);"></a>6.background:rgba(0,0,0,.3);</h4><ul>
<li><strong>注意</strong>：</li>
<li>背景半透明是指盒子背景半透明，盒子里面的内容不受影响</li>
<li>CSS3 新增属性，是 IE9+ 版本浏览器才支持的，但是现在实际开发,我们不太关注兼容性写法了,可以放心使用</li>
</ul>
<h3 id="css文本"><a href="#css文本" class="headerlink" title="css文本"></a>css文本</h3><p>css字体属性:<br>    字体大小：<br>    CSS 使用 font-size 属性定义字体大小。<br>语法：<br>     p {  </p>
<h4 id="font-size-20px"><a href="#font-size-20px" class="headerlink" title="font-size: 20px;"></a>font-size: 20px;</h4><p>​    }<br>​    1.px（像素）大小是我们网页的最常用的单位<br>​    2.谷歌浏览器默认的文字大小为16px<br>​    3.不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小<br>​    4.可以给 body 指定整个页面文字的大小<br>###字体粗细：<br>​    CSS 使用 font-weight 属性设置文本字体的粗细。<br>语法：<br>​    p {  </p>
<h4 id="font-weight-bold"><a href="#font-weight-bold" class="headerlink" title="font-weight: bold;"></a>font-weight: bold;</h4><p>​    }</p>
<p>1.学会让加粗标签（比如 h 和 strong 等) 不加粗，或者其他标签加粗<br>2.实际开发时，我们更喜欢用数字表示粗细<br>###字体样式：<br>    CSS 使用 font-style 属性设置文本的风格。<br>语法：<br>    p {  </p>
<h4 id="font-style-normal"><a href="#font-style-normal" class="headerlink" title="font-style: normal;"></a>font-style: normal;</h4><p>​    }</p>
<p>body {  </p>
<h4 id="font-font-style-font-weight-font-size-line-height-font-family"><a href="#font-font-style-font-weight-font-size-line-height-font-family" class="headerlink" title="font: font-style  font-weight  font-size/line-height  font-family;"></a>font: font-style  font-weight  font-size/line-height  font-family;</h4><p>}</p>
<p>使用 font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开 不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用</p>
<p>##css文本属性：<br>###文本颜色：<br>    color 属性用于定义文本的颜色。<br>语法：<br>    div { </p>
<h4 id="color-red"><a href="#color-red" class="headerlink" title="color: red;"></a>color: red;</h4><p>​    }</p>
<p>###修饰文本：<br>    语法：<br>     div { </p>
<h4 id="text-decoration：underline；"><a href="#text-decoration：underline；" class="headerlink" title="text-decoration：underline；"></a>text-decoration：underline；</h4><p>​     }</p>
<p>###文本缩进<br>语法：<br>    div { </p>
<h4 id="text-indent：20px；"><a href="#text-indent：20px；" class="headerlink" title="text-indent：20px；"></a>text-indent：20px；</h4><p>​    }<br>​    div {<br>​        text-indent：2em；<br>​    }</p>
<h3 id="css三大特性"><a href="#css三大特性" class="headerlink" title="css三大特性"></a>css三大特性</h3><h4 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h4><p>相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题</p>
<p>​        层叠性原则:</p>
<ul>
<li>样式冲突，遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式</li>
<li>样式不冲突，不会层叠</li>
</ul>
<h4 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h4><p>CSS中的继承: 子标签会继承父标签的某些样式，如文本颜色和字号。恰当地使用继承可以简化代码，降低 CSS 样式的复杂性。</p>
<p>（text-，font-，line-这些元素开头的可以继承，以及color属性）</p>
<p>行高的继承性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>:<span class="number">12px</span>/<span class="number">1.5</span> Microsoft YaHei；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>行高可以跟单位也可以不跟单位</li>
<li>如果子元素没有设置行高，则会继承父元素的行高为 1.5</li>
<li>此时子元素的行高是：当前子元素的文字大小 * 1.5</li>
<li>body 行高 1.5  这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高</li>
</ul>
<h4 id="优先性"><a href="#优先性" class="headerlink" title="优先性"></a>优先性</h4><p>当同一个元素指定多个选择器，就会有优先级的产生。</p>
<ul>
<li>选择器相同，则执行层叠性</li>
<li>选择器不同，则根据选择器权重执行</li>
</ul>
<p>优先级计算表格</p>
<p>继承 * :0,0,0,0</p>
<p>元素选择器:0,0,0,1</p>
<p>类选择器，伪类选择器:0,0,1,0</p>
<p>id选择器: 0,1,0,0</p>
<p>行内样式1,0,0,0</p>
<p>!important ：∞</p>
<p>优先级注意点:</p>
<ol>
<li><p>权重是有4组数字组成,但是不会有进位。</p>
</li>
<li><p>可以理解为类选择器永远大于元素选择器, id选择器永远大于类选择器,以此类推..</p>
</li>
<li><p>等级判断从左向右，如果某一位数值相同，则判断下一位数值。</p>
</li>
<li><p>可以简单记忆法:  通配符和继承权重为0, 标签选择器为1,类(伪类)选择器为 10, id选择器 100, 行内样式表为 1000, !important 无穷大.</p>
</li>
<li><p>继承的权重是0， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。</p>
</li>
</ol>
<p>权重叠加：如果是复合选择器，则会有权重叠加，需要计算权重。</p>
<ul>
<li>div ul  li   ——&gt;      0,0,0,3</li>
<li>.nav ul li   ——&gt;      0,0,1,2</li>
<li>a:hover      —–—&gt;   0,0,1,1</li>
<li>.nav a       ——&gt;      0,0,1,1</li>
</ul>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><h4 id="1、网页布局的本质"><a href="#1、网页布局的本质" class="headerlink" title="1、网页布局的本质"></a>1、网页布局的本质</h4><p>网页布局的核心本质： 就是利用 CSS 摆盒子。</p>
<p>网页布局过程：</p>
<ol>
<li>先准备好相关的网页元素，网页元素基本都是盒子 Box 。</li>
<li>利用 CSS 设置好盒子样式，然后摆放到相应位置。</li>
<li>往盒子里面装内容</li>
</ol>
<h4 id="2、盒子模型（Box-Model）组成"><a href="#2、盒子模型（Box-Model）组成" class="headerlink" title="2、盒子模型（Box Model）组成"></a>2、盒子模型（Box Model）组成</h4><p>​        盒子模型：把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。</p>
<p>​        CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：<strong>边框</strong>、<strong>外边距</strong>、<strong>内边距</strong>、和 <strong>实际内容</strong></p>
<h4 id="3、边框（border）"><a href="#3、边框（border）" class="headerlink" title="3、边框（border）"></a>3、边框（border）</h4><h5 id="3-1、边框的使用"><a href="#3-1、边框的使用" class="headerlink" title="3.1、边框的使用"></a>3.1、边框的使用</h5><p>1、border可以设置元素的边框。边框有三部分组成：边框宽度(粗细) 边框样式  边框颜色；</p>
<p>2、语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span> : border-width || border-style || border-color;   </span><br></pre></td></tr></table></figure>

<p>边框样式 border-style 可以设置如下值：</p>
<ul>
<li>none：没有边框即忽略所有边框的宽度（默认值）</li>
<li>solid：边框为单实线(最为常用的)</li>
<li>dashed：边框为虚线  </li>
<li>dotted：边框为点线</li>
</ul>
<p>3、边框的合写分写</p>
<p>边框简写：</p>
<h6 id="border-1px-solid-red"><a href="#border-1px-solid-red" class="headerlink" title="border: 1px solid red;"></a>border: 1px solid red;</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;  </span><br></pre></td></tr></table></figure>

<p>边框分开写法：</p>
<h6 id="border-top-1px-solid-red"><a href="#border-top-1px-solid-red" class="headerlink" title="border-top: 1px solid red;"></a>border-top: 1px solid red;</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-top</span>: <span class="number">1px</span> solid red;  <span class="comment">/* 只设定上边框， 其余同理 */</span>   </span><br></pre></td></tr></table></figure>

<h5 id="3-2、表格的细线边框"><a href="#3-2、表格的细线边框" class="headerlink" title="3.2、表格的细线边框"></a>3.2、表格的细线边框</h5><p>1、border-collapse 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。</p>
<p>2、语法：</p>
<h6 id="border-collapse-collapse"><a href="#border-collapse-collapse" class="headerlink" title="border-collapse:collapse;"></a>border-collapse:collapse;</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-collapse</span>:collapse; </span><br></pre></td></tr></table></figure>

<p>collapse 单词是合并的意思</p>
<p>border-collapse: collapse; 表示相邻边框合并在一起</p>
<h5 id="3-3、边框会影响盒子实际大小"><a href="#3-3、边框会影响盒子实际大小" class="headerlink" title="3.3、边框会影响盒子实际大小"></a>3.3、边框会影响盒子实际大小</h5><p>边框会额外增加盒子的实际大小。因此我们有两种方案解决：</p>
<ul>
<li>测量盒子大小的时候,不量边框。</li>
<li>如果测量的时候包含了边框,则需要 width/height 减去边框宽度</li>
</ul>
<h4 id="4、内边距（padding）"><a href="#4、内边距（padding）" class="headerlink" title="4、内边距（padding）"></a>4、内边距（padding）</h4><h5 id="4-1、内边距的使用方式"><a href="#4-1、内边距的使用方式" class="headerlink" title="4.1、内边距的使用方式"></a>4.1、内边距的使用方式</h5><p>1、padding 属性用于设置内边距，即边框与内容之间的距离。</p>
<p>2、语法：</p>
<h6 id="padding-上-右-下-左"><a href="#padding-上-右-下-左" class="headerlink" title="padding:上 右 下 左;"></a>padding:上 右 下 左;</h6><h5 id="4-2、内边距会影响盒子实际大小"><a href="#4-2、内边距会影响盒子实际大小" class="headerlink" title="4.2、内边距会影响盒子实际大小"></a>4.2、内边距会影响盒子实际大小</h5><p>1、当我们给盒子指定 padding 值之后，发生了 2 件事情：</p>
<ol>
<li>内容和边框有了距离，添加了内边距。</li>
<li>padding影响了盒子实际大小。</li>
</ol>
<p>2、内边距对盒子大小的影响：</p>
<ul>
<li>如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子。</li>
<li>如何盒子本身没有指定width/height属性, 则此时padding不会撑开盒子大小。</li>
</ul>
<p>3、解决方案：</p>
<p>​        如果保证盒子跟效果图大小保持一致，则让 width/height 减去多出来的内边距大小即可。</p>
<h4 id="5、外边距（margin）"><a href="#5、外边距（margin）" class="headerlink" title="5、外边距（margin）"></a>5、外边距（margin）</h4><h5 id="5-1、外边距的使用方式"><a href="#5-1、外边距的使用方式" class="headerlink" title="5.1、外边距的使用方式"></a>5.1、外边距的使用方式</h5><p>margin 属性用于设置外边距，即控制盒子和盒子之间的距离。</p>
<h5 id="5-2、外边距典型应用"><a href="#5-2、外边距典型应用" class="headerlink" title="5.2、外边距典型应用"></a>5.2、外边距典型应用</h5><p>外边距可以让块级盒子水平居中的两个条件：</p>
<ul>
<li>盒子必须指定了宽度（width）。</li>
<li>盒子左右的外边距都设置为 auto 。</li>
</ul>
<p>常见的写法，以下三种都可以</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin-left</span>: auto;   <span class="attribute">margin-right</span>: auto;</span><br><span class="line"><span class="attribute">margin</span>: auto;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br></pre></td></tr></table></figure>

<p>注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align:center 即可。</p>
<h5 id="5-3、外边距合并"><a href="#5-3、外边距合并" class="headerlink" title="5.3、外边距合并"></a>5.3、外边距合并</h5><p>使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。</p>
<p>主要有两种情况:</p>
<p>1、相邻块元素垂直外边距的合并</p>
<p>​        当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并。</p>
<p>决方案：<br>        尽量只给一个盒子添加 margin 值。</p>
<p>2、嵌套块元素垂直外边距的塌陷</p>
<p>​        对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。</p>
<p>解决方案：</p>
<ul>
<li>可以为父元素定义上边框。</li>
<li>可以为父元素定义上内边距。</li>
<li>可以为父元素添加 overflow:hidden。</li>
</ul>
<h5 id="5-4、清除内外边距"><a href="#5-4、清除内外边距" class="headerlink" title="5.4、清除内外边距"></a>5.4、清除内外边距</h5><p>​        网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">   <span class="attribute">padding</span>:<span class="number">0</span>;   <span class="comment">/* 清除内边距 */</span></span><br><span class="line">   <span class="attribute">margin</span>:<span class="number">0</span>;    <span class="comment">/* 清除外边距 */</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​        注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。但是转换为块级和行内块元素就可以了</p>
<h3 id="其他样式"><a href="#其他样式" class="headerlink" title="其他样式"></a>其他样式</h3><h4 id="1、圆角边框"><a href="#1、圆角边框" class="headerlink" title="1、圆角边框"></a>1、圆角边框</h4><h5 id="border-radius-length"><a href="#border-radius-length" class="headerlink" title="border-radius:length;"></a>border-radius:length;</h5><ul>
<li>参数值可以为数值或百分比的形式</li>
<li>如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 50%</li>
<li>该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角</li>
<li>分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和border-bottom-left-radius</li>
<li>兼容性 ie9+ 浏览器支持, 但是不会影响页面布局,可以放心使用</li>
</ul>
<h4 id="2-盒子阴影"><a href="#2-盒子阴影" class="headerlink" title="2.盒子阴影"></a>2.盒子阴影</h4><p>CSS3 中新增了盒子阴影，我们可以使用 box-shadow 属性为盒子添加阴影。<br>语法：</p>
<h5 id="box-shadow-h-shadow-v-shadow-blur-spread-color-inset"><a href="#box-shadow-h-shadow-v-shadow-blur-spread-color-inset" class="headerlink" title="box-shadow: h-shadow v-shadow blur spread color inset;"></a>box-shadow: h-shadow v-shadow blur spread color inset;</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: h-shadow v-shadow blur spread color inset; </span><br></pre></td></tr></table></figure>

<p>h 、 v 水平 垂直 </p>
<p>blur 模糊距离</p>
<p>sprend 阴影尺寸</p>
<p>color 阴影颜色</p>
<p>inset 可将外部outset阴影改为内部阴影</p>
<h4 id="3、文字阴影"><a href="#3、文字阴影" class="headerlink" title="3、文字阴影"></a>3、文字阴影</h4><p>在 CSS3 中，我们可以使用 text-shadow 属性将阴影应用于文本。<br>语法：</p>
<h5 id="text-shadow-h-shadow-v-shadow-blur-color"><a href="#text-shadow-h-shadow-v-shadow-blur-color" class="headerlink" title="text-shadow: h-shadow v-shadow blur color;"></a>text-shadow: h-shadow v-shadow blur color;</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-shadow</span>: h-shadow v-shadow blur color;</span><br></pre></td></tr></table></figure>

<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><h4 id="1、传统网页布局的三种方式"><a href="#1、传统网页布局的三种方式" class="headerlink" title="1、传统网页布局的三种方式"></a>1、传统网页布局的三种方式</h4><p>​    CSS 提供了三种传统布局方式(简单说,就是盒子如何进行排列顺序)：</p>
<ul>
<li><p>普通流（标准流）</p>
</li>
<li><p>浮动</p>
</li>
<li><p>定位</p>
<p>这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了。</p>
</li>
</ul>
<p>注意：实际开发中，一个页面基本都包含了这三种布局方式（后面移动端学习新的布局方式） 。</p>
<h4 id="2、标准流（普通流-文档流）"><a href="#2、标准流（普通流-文档流）" class="headerlink" title="2、标准流（普通流/文档流）"></a>2、标准流（普通流/文档流）</h4><p>所谓的标准流:  就是标签按照规定好默认方式排列</p>
<ol>
<li>块级元素会独占一行，从上向下顺序排列。常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table</li>
<li>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。常用元素：span、a、i、em 等 </li>
</ol>
<h4 id="3、为什么需要浮动？"><a href="#3、为什么需要浮动？" class="headerlink" title="3、为什么需要浮动？"></a>3、为什么需要浮动？</h4><p>​        总结： 有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。 因为浮动可以改变元素标签默认的排列方式.</p>
<p>​        浮动最典型的应用：可以让多个块级元素一行内排列显示。</p>
<p>​        网页布局第一准则：<strong>多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动</strong>。</p>
<h4 id="4、什么是浮动？"><a href="#4、什么是浮动？" class="headerlink" title="4、什么是浮动？"></a>4、什么是浮动？</h4><p>​        float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。</p>
<p>语法：</p>
<h5 id="选择器-float-属性值"><a href="#选择器-float-属性值" class="headerlink" title="选择器 { float: 属性值; }"></a>选择器 { float: 属性值; }</h5><h4 id="5、浮动特性"><a href="#5、浮动特性" class="headerlink" title="5、浮动特性"></a>5、浮动特性</h4><p>加了浮动之后的元素,会具有很多特性,需要我们掌握的.</p>
<p>1、浮动元素会脱离标准流(脱标：浮动的盒子不再保留原先的位置)</p>
<p>2、浮动的元素会一行内显示并且元素顶部对齐</p>
<p>注意： </p>
<p>​        浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。</p>
<p>3、浮动的元素会具有行内块元素的特性</p>
<p>​        浮动元素的大小根据内容来决定</p>
<p>​        浮动的盒子中间是没有缝隙的</p>
<h4 id="6、浮动元素经常和标准流父级搭配使用"><a href="#6、浮动元素经常和标准流父级搭配使用" class="headerlink" title="6、浮动元素经常和标准流父级搭配使用"></a>6、浮动元素经常和标准流父级搭配使用</h4><p>为了约束浮动元素位置, 我们网页布局一般采取的策略是:</p>
<p>​        先用标准流父元素排列上下位置, 之后内部子元素采取浮动排列左右位置.  符合网页布局第一准侧</p>
<h3 id="常见网页布局"><a href="#常见网页布局" class="headerlink" title="常见网页布局"></a>常见网页布局</h3><h4 id="浮动布局注意点"><a href="#浮动布局注意点" class="headerlink" title="浮动布局注意点"></a>浮动布局注意点</h4><p>1、浮动和标准流的父盒子搭配。</p>
<p>先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置</p>
<p>2、一个元素浮动了，理论上其余的兄弟元素也要浮动。</p>
<p>一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动，以防止引起问题。</p>
<p>浮动的盒子只会影响浮动盒子后面的标准流,不会影响前面的标准流.</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><h4 id="1、为什么需要清除浮动？"><a href="#1、为什么需要清除浮动？" class="headerlink" title="1、为什么需要清除浮动？"></a>1、为什么需要清除浮动？</h4><p>​        由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子。</p>
<h4 id="2、清除浮动本质"><a href="#2、清除浮动本质" class="headerlink" title="2、清除浮动本质"></a>2、清除浮动本质</h4><p>清除浮动的本质是清除浮动元素造成的影响：浮动的子标签无法撑开父盒子的高度</p>
<p>注意：</p>
<ul>
<li>如果父盒子本身有高度，则不需要清除浮动</li>
<li>清除浮动之后，父级就会根据浮动的子盒子自动检测高度。</li>
<li>父级有了高度，就不会影响下面的标准流了</li>
</ul>
<h4 id="3、清除浮动样式"><a href="#3、清除浮动样式" class="headerlink" title="3、清除浮动样式"></a>3、清除浮动样式</h4><p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;<span class="attribute">clear</span>:属性值;&#125; </span><br></pre></td></tr></table></figure>

<p>我们实际工作中， 几乎只用</p>
<h5 id="clear-both"><a href="#clear-both" class="headerlink" title="clear: both;"></a>clear: both;</h5><p>清除（左右）浮动影响</p>
<p>Left; right;both;</p>
<p>清除浮动的策略是:  闭合浮动. </p>
<h4 id="4、清除浮动的多种方式"><a href="#4、清除浮动的多种方式" class="headerlink" title="4、清除浮动的多种方式"></a>4、清除浮动的多种方式</h4><h5 id="4-1、额外标签法"><a href="#4-1、额外标签法" class="headerlink" title="4.1、额外标签法"></a>4.1、额外标签法</h5><p>额外标签法也称为隔墙法，是 W3C 推荐的做法。</p>
<p>使用方式：</p>
<p>​        额外标签法会在浮动元素末尾添加一个空的标签。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如 <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear:both&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>，或者其他标签（如<span class="tag">&lt;<span class="name">br</span> /&gt;</span>等）。</span><br></pre></td></tr></table></figure>

<p>​        优点： 通俗易懂，书写方便</p>
<p>​        缺点： 添加许多无意义的标签，结构化较差</p>
<p>​        注意： 要求这个新的空标签必须是块级元素。</p>
<p>总结:</p>
<p>​    1、清除浮动本质是?</p>
<p>​            清除浮动的本质是清除浮动元素脱离标准流造成的影响</p>
<p>​    2、清除浮动策略是?</p>
<p>​        闭合浮动.  只让浮动在父盒子内部影响,不影响父盒子外面的其他盒子.</p>
<p>​    3、额外标签法?</p>
<p>​        隔墙法, 就是在最后一个浮动的子元素后面加一个额外标签, 添加 清除浮动样式.</p>
<p>​            实际工作可能会遇到,但是不常用</p>
<h5 id="4-2、父级添加-overflow-属性"><a href="#4-2、父级添加-overflow-属性" class="headerlink" title="4.2、父级添加 overflow 属性"></a>4.2、父级添加 overflow 属性</h5><p>可以给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll 。</p>
<p>例如：</p>
<h6 id="overflow-hidden-auto-scroll"><a href="#overflow-hidden-auto-scroll" class="headerlink" title="overflow:hidden | auto | scroll;"></a>overflow:hidden | auto | scroll;</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">overflow:hidden | auto | scroll;</span><br></pre></td></tr></table></figure>

<p>优点：代码简洁</p>
<p>缺点：无法显示溢出的部分</p>
<p>注意：是给父元素添加代码</p>
<h5 id="4-3、父级添加after伪元素"><a href="#4-3、父级添加after伪元素" class="headerlink" title="4.3、父级添加after伪元素"></a>4.3、父级添加after伪元素</h5><p>:after 方式是额外标签法的升级版。给父元素添加：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after &#123;  </span><br><span class="line">  content: <span class="string">&quot;&quot;</span>; </span><br><span class="line">  <span class="attribute">display</span>: block; </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">clear</span>: both; </span><br><span class="line">  <span class="attribute">visibility</span>: hidden;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;  <span class="comment">/* IE6、7 专有 */</span> </span><br><span class="line">  *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>优点：没有增加标签，结构更简单</p>
<p>缺点：照顾低版本浏览器</p>
<p>代表网站： 百度、淘宝网、网易等</p>
<h5 id="4-4、父级添加双伪元素"><a href="#4-4、父级添加双伪元素" class="headerlink" title="4.4、父级添加双伪元素"></a>4.4、父级添加双伪元素</h5><p>给父元素添加</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:before,.clearfix:after &#123;</span><br><span class="line">  content:<span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>:table; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">  clear:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">   *zoom:<span class="number">1</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>优点：代码更简洁</p>
<p>缺点：照顾低版本浏览器</p>
<p>代表网站：小米、腾讯等</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>为什么需要清除浮动？</p>
<ol>
<li>父级没高度。</li>
<li>子盒子浮动了。</li>
<li>影响下面布局了，我们就应该清除浮动了。</li>
</ol>
<h3 id="css书写顺序（重要）"><a href="#css书写顺序（重要）" class="headerlink" title="css书写顺序（重要）"></a>css书写顺序（重要）</h3><p>建议遵循以下顺序：</p>
<h4 id="1-布局定位属性："><a href="#1-布局定位属性：" class="headerlink" title="1.布局定位属性："></a>1.<strong>布局定位属性</strong>：</h4><p>display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）</p>
<h4 id="2-自身属性："><a href="#2-自身属性：" class="headerlink" title="2.自身属性："></a>2.<strong>自身属性</strong>：</h4><p>width / height / margin / padding / border / background</p>
<h4 id="3-文本属性："><a href="#3-文本属性：" class="headerlink" title="3.文本属性："></a>3.<strong>文本属性</strong>：</h4><p>color / font / text-decoration / text-align / vertical-align / white- space / break-word</p>
<h4 id="4-其他属性（CSS3）："><a href="#4-其他属性（CSS3）：" class="headerlink" title="4.其他属性（CSS3）："></a>4.<strong>其他属性（CSS3）</strong>：</h4><p>content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …</p>
<h3 id="定位-position"><a href="#定位-position" class="headerlink" title="定位(position)"></a>定位(position)</h3><h4 id="1-1-为什么使用定位"><a href="#1-1-为什么使用定位" class="headerlink" title="1.1 为什么使用定位"></a>1.1 为什么使用定位</h4><p><strong>场景1</strong>： 某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子.</p>
<p><strong>场景2</strong>：当我们滚动窗口的时候，盒子是固定屏幕某个位置的。</p>
<p>所以：</p>
<p>1.浮动可以让多个块级盒子一行没有缝隙排列显示， 经常用于横向排列盒子。</p>
<p>2.定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。</p>
<h4 id="1-2-1-边偏移（方位名词）"><a href="#1-2-1-边偏移（方位名词）" class="headerlink" title="1.2.1 边偏移（方位名词）"></a>1.2.1 边偏移（方位名词）</h4><p><strong>边偏移</strong> 就是定位的盒子移动到最终位置。有 top、bottom、left 和 right  4 个属性。</p>
<table>
<thead>
<tr>
<th>边偏移属性</th>
<th align="left">示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>top</code></td>
<td align="left"><code>top: 80px</code></td>
<td><strong>顶端</strong>偏移量，定义元素相对于其父元素<strong>上边线的距离</strong>。</td>
</tr>
<tr>
<td><code>bottom</code></td>
<td align="left"><code>bottom: 80px</code></td>
<td><strong>底部</strong>偏移量，定义元素相对于其父元素<strong>下边线的距离</strong>。</td>
</tr>
<tr>
<td><code>left</code></td>
<td align="left"><code>left: 80px</code></td>
<td><strong>左侧</strong>偏移量，定义元素相对于其父元素<strong>左边线的距离</strong>。</td>
</tr>
<tr>
<td><code>right</code></td>
<td align="left"><code>right: 80px</code></td>
<td><strong>右侧</strong>偏移量，定义元素相对于其父元素<strong>右边线的距离</strong></td>
</tr>
</tbody></table>
<p>定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。</p>
<h4 id="1-2-2-定位模式-position"><a href="#1-2-2-定位模式-position" class="headerlink" title="1.2.2 定位模式 (position)"></a>1.2.2 定位模式 (position)</h4><p>在 CSS 中，通过 <code>position</code> 属性定义元素的<strong>定位模式</strong>，语法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">    <span class="attribute">position</span>: 属性值; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。</p>
<p>定位模式决定元素的定位方式 ，它通过 CSS 的 position 属性来设置，其值可以分为四个：</p>
<table>
<thead>
<tr>
<th>值</th>
<th align="center">语义</th>
</tr>
</thead>
<tbody><tr>
<td><code>static</code></td>
<td align="center"><strong>静态</strong>定位</td>
</tr>
<tr>
<td><code>relative</code></td>
<td align="center"><strong>相对</strong>定位</td>
</tr>
<tr>
<td><code>absolute</code></td>
<td align="center"><strong>绝对</strong>定位</td>
</tr>
<tr>
<td><code>fixed</code></td>
<td align="center"><strong>固定</strong>定位</td>
</tr>
</tbody></table>
<h4 id="1-3-定位模式介绍"><a href="#1-3-定位模式介绍" class="headerlink" title="1.3 定位模式介绍"></a>1.3 定位模式介绍</h4><h5 id="1-3-1-静态定位-static-了解"><a href="#1-3-1-静态定位-static-了解" class="headerlink" title="1.3.1.  静态定位(static) - 了解"></a>1.3.1.  静态定位(static) - 了解</h5><ul>
<li><p><strong>静态定位</strong>是元素的<strong>默认</strong>定位方式，<strong>无定位的意思</strong>。它相当于 border 里面的none，静态定位static，不要定位的时候用。</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">    position: static; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>静态定位 按照标准流特性摆放位置，它没有边偏移。</p>
</li>
<li><p>静态定位在布局时我们几乎不用的 </p>
</li>
</ul>
<h5 id="1-3-2-相对定位-relative-重要"><a href="#1-3-2-相对定位-relative-重要" class="headerlink" title="1.3.2. 相对定位(relative) - 重要"></a>1.3.2. 相对定位(relative) - 重要</h5><ul>
<li><strong>相对定位</strong>是元素在移动位置的时候，是相对于它自己<strong>原来的位置</strong>来说的（自恋型）。</li>
<li>语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">	position: relative; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>相对定位的特点：（务必记住）</p>
<ul>
<li><p>1.它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）。</p>
</li>
<li><p>2.<strong>原来</strong>在标准流的<strong>位置</strong>继续占有，后面的盒子仍然以标准流的方式对待它。</p>
<p>因此，<strong>相对定位并没有脱标</strong>。它最典型的应用是给绝对定位当爹的。。。</p>
</li>
</ul>
</li>
</ul>
<h5 id="1-3-3-绝对定位-absolute-重要"><a href="#1-3-3-绝对定位-absolute-重要" class="headerlink" title="1.3.3. 绝对定位(absolute) - 重要"></a>1.3.3. 绝对定位(absolute) - 重要</h5><h6 id="1-3-3-1-绝对定位的介绍"><a href="#1-3-3-1-绝对定位的介绍" class="headerlink" title="1.3.3.1 绝对定位的介绍"></a>1.3.3.1 绝对定位的介绍</h6><ul>
<li><p><strong>绝对定位</strong>是元素在移动位置的时候，是相对于它<strong>祖先元素</strong>来说的（拼爹型）。</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">	position: absolute; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p><strong>完全脱标</strong> —— 完全不占位置；  </p>
</li>
<li><p><strong>父元素没有定位</strong>，则以<strong>浏览器</strong>为准定位（Document 文档）。</p>
</li>
<li><p><strong>父元素要有定位</strong></p>
<ul>
<li>元素将依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。</li>
</ul>
</li>
<li><p><strong>绝对定位的特点总结</strong>：（务必记住）</p>
<p>1.如果<strong>没有祖先元素</strong>或者<strong>祖先元素没有定位</strong>，则以浏览器为基准定位（Document 文档）。</p>
<p>2.如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置。</p>
<p>3.绝对定位<strong>不再占有原先的位置</strong>。所以绝对定位是脱离标准流的。（脱标）</p>
</li>
</ol>
<h6 id="1-3-3-2-定位口诀-——-子绝父相"><a href="#1-3-3-2-定位口诀-——-子绝父相" class="headerlink" title="1.3.3.2 定位口诀 —— 子绝父相"></a>1.3.3.2 定位口诀 —— 子绝父相</h6><p>弄清楚这个口诀，就明白了绝对定位和相对定位的使用场景。</p>
<p>这个<strong>“子绝父相”</strong>太重要了，是我们学习定位的<strong>口诀</strong>，是定位中最常用的一种方式这句话的意思是：<strong>子级是绝对定位的话，父级要用相对定位。</strong></p>
<p>因为绝对定位的盒子是拼爹的，所以要和父级搭配一起来使用。</p>
<p>①子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。</p>
<p>②父盒子需要加定位限制子盒子在父盒子内显示。</p>
<p>③父盒子布局时，需要占有位置，因此父亲只能是相对定位。</p>
<p>这就是子绝父相的由来，所以<strong>相对定位经常用来作为绝对定位的父级</strong>。</p>
<p>总结： <strong>因为父级需要占有位置，因此是相对定位， 子盒子不需要占有位置，则是绝对定位</strong></p>
<p>当然，子绝父相不是永远不变的，如果父元素不需要占有位置，<strong>子绝父绝</strong>也会遇到。</p>
<h5 id="1-3-4-固定定位-fixed-重要"><a href="#1-3-4-固定定位-fixed-重要" class="headerlink" title="1.3.4. 固定定位(fixed) - 重要"></a>1.3.4. 固定定位(fixed) - 重要</h5><ul>
<li><p><strong>固定定位</strong>是元素<strong>固定于浏览器可视区的位置</strong>。（认死理型）   主要使用场景： 可以在浏览器页面滚动时元素的位置不会改变。</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">	position: fixed; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>固定定位的特点：（务必记住）：</p>
<p>1.以浏览器的可视窗口为参照点移动元素。</p>
<ul>
<li>跟父元素没有任何关系</li>
<li>不随滚动条滚动。</li>
</ul>
<p>2.固定定位<strong>不在占有原先的位置</strong>。</p>
</li>
<li><p>固定定位也是<strong>脱标</strong>的，其实<strong>固定定位也可以看做是一种特殊的绝对定位</strong>。（认死理型） </p>
<ul>
<li><strong>完全脱标</strong>—— 完全不占位置；</li>
<li>只认<strong>浏览器的可视窗口</strong> —— <code>浏览器可视窗口 + 边偏移属性</code> 来设置元素的位置；<ul>
<li>跟父元素没有任何关系；单独使用的</li>
<li>不随滚动条滚动。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="1-3-5-粘性定位-sticky-了解"><a href="#1-3-5-粘性定位-sticky-了解" class="headerlink" title="1.3.5 粘性定位(sticky) - 了解"></a>1.3.5 粘性定位(sticky) - 了解</h5><ul>
<li><p><strong>粘性定位</strong>可以被认为是相对定位和固定定位的混合。 Sticky  粘性的 </p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">    position: sticky; </span><br><span class="line">    top: 10px; </span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p>粘性定位的特点：</p>
<p>1.以浏览器的可视窗口为参照点移动元素（固定定位特点）</p>
<p>2.粘性定位占有原先的位置（相对定位特点）</p>
<p>3.必须添加 top 、left、right、bottom <strong>其中一个</strong>才有效</p>
<p>跟页面滚动搭配使用。 兼容性较差，IE 不支持。</p>
</li>
</ul>
<h5 id="1-3-6-定位总结"><a href="#1-3-6-定位总结" class="headerlink" title="1.3.6 定位总结"></a>1.3.6 定位总结</h5><table>
<thead>
<tr>
<th><strong>定位模式</strong></th>
<th><strong>是否脱标</strong></th>
<th><strong>移动位置</strong></th>
<th><strong>是否常用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static   静态定位</td>
<td>否</td>
<td>不能使用边偏移</td>
<td>很少</td>
</tr>
<tr>
<td><strong>relative 相对定位</strong></td>
<td><strong>否 (占有位置)</strong></td>
<td><strong>相对于自身位置移动</strong></td>
<td><strong>基本单独使用</strong></td>
</tr>
<tr>
<td><strong>absolute绝对定位</strong></td>
<td><strong>是（不占有位置）</strong></td>
<td><strong>带有定位的父级</strong></td>
<td><strong>要和定位父级元素搭配使用</strong></td>
</tr>
<tr>
<td><strong>fixed 固定定位</strong></td>
<td><strong>是（不占有位置）</strong></td>
<td><strong>浏览器可视区</strong></td>
<td><strong>单独使用，不需要父级</strong></td>
</tr>
<tr>
<td>sticky 粘性定位</td>
<td>否   (占有位置)</td>
<td>浏览器可视区</td>
<td>当前阶段少</td>
</tr>
</tbody></table>
<ul>
<li><p>一定记住 相对定位、固定定位、绝对定位 两个大的特点： 1. 是否占有位置（脱标否） 2. 以谁为基准点移动位置。</p>
</li>
<li><p>学习定位重点学会子绝父相。</p>
</li>
<li><p>注意：</p>
</li>
</ul>
<ol>
<li><strong>边偏移</strong>需要和<strong>定位模式</strong>联合使用，<strong>单独使用无效</strong>；</li>
<li><code>top</code> 和 <code>bottom</code> 不要同时使用；</li>
<li><code>left</code> 和 <code>right</code> 不要同时使用。</li>
</ol>
<h5 id="1-3-7定位应用"><a href="#1-3-7定位应用" class="headerlink" title="1.3.7定位应用"></a>1.3.7定位应用</h5><h6 id="1-3-7-1-固定定位小技巧：-固定在版心左侧位置。"><a href="#1-3-7-1-固定定位小技巧：-固定在版心左侧位置。" class="headerlink" title="1.3.7.1.  固定定位小技巧： 固定在版心左侧位置。"></a>1.3.7.1.  固定定位小技巧： 固定在版心左侧位置。</h6><p>小算法：</p>
<p>1.让固定定位的盒子 left: 50%.  走到浏览器可视区（也可以看做版心） 的一半位置。</p>
<p>2.让固定定位的盒子 margin-left: 版心宽度的一半距离。  多走 版心宽度的一半位置</p>
<p>就可以让固定定位的盒子<strong>贴着版心右侧对齐</strong>了。</p>
<h6 id="1-3-7-2堆叠排序z-index-1"><a href="#1-3-7-2堆叠排序z-index-1" class="headerlink" title="1.3.7.2堆叠排序z-index:1;"></a>1.3.7.2堆叠排序z-index:1;</h6><h4 id="1-4定位拓展"><a href="#1-4定位拓展" class="headerlink" title="1.4定位拓展"></a>1.4定位拓展</h4><h5 id="1-4-1-绝对定位的盒子居中"><a href="#1-4-1-绝对定位的盒子居中" class="headerlink" title="1.4.1 绝对定位的盒子居中"></a>1.4.1 绝对定位的盒子居中</h5><blockquote>
<p><strong>注意</strong>：加了<strong>绝对定位/固定定位的盒子</strong>不能通过设置 <code>margin: auto</code> 设置<strong>水平居中</strong>。</p>
<p>但是可以通过以下计算方法实现水平和垂直居中，可以按照下图的方法：</p>
</blockquote>
<ol>
<li><code>left: 50%;</code>：让<strong>盒子的左侧</strong>移动到<strong>父级元素的水平中心位置</strong>；</li>
<li><code>margin-left: -100px;</code>：让盒子<strong>向左</strong>移动<strong>自身宽度的一半</strong>。</li>
</ol>
<h5 id="1-4-2-定位特殊特性"><a href="#1-4-2-定位特殊特性" class="headerlink" title="1.4.2 定位特殊特性"></a>1.4.2 定位特殊特性</h5><p>绝对定位和固定定位也和浮动类似。</p>
<p>1.行内元素添加绝对或者固定定位，可以直接设置高度和宽度。</p>
<p>2.块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。</p>
<p>前面我们讲过， display 是 显示模式， 可以改变显示模式有以下方式:</p>
<ul>
<li>可以用inline-block  转换为行内块</li>
<li>可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）</li>
<li>绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。</li>
</ul>
<p>所以说， 一个行内的盒子，如果加了<strong>浮动</strong>、<strong>固定定位</strong>和<strong>绝对定位</strong>，不用转换，就可以给这个盒子直接设置宽度和高度等。</p>
<h5 id="1-4-3-脱标的盒子不会触发外边距塌陷"><a href="#1-4-3-脱标的盒子不会触发外边距塌陷" class="headerlink" title="1.4.3 脱标的盒子不会触发外边距塌陷"></a>1.4.3 脱标的盒子不会触发外边距塌陷</h5><p>浮动元素、<strong>绝对定位(固定定位）</strong>元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的）</p>
<p>也就是说，我们给盒子改为了浮动或者定位，就不会有垂直<strong>外边距合并的问题</strong>了。</p>
<h5 id="1-4-4-绝对定位（固定定位）会完全压住盒子"><a href="#1-4-4-绝对定位（固定定位）会完全压住盒子" class="headerlink" title="1.4.4 绝对定位（固定定位）会完全压住盒子"></a>1.4.4 绝对定位（固定定位）会完全压住盒子</h5><p>浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）</p>
<p>但是绝对定位（固定定位） 会压住下面标准流所有的内容。</p>
<p>浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。 文字会围绕浮动元素</p>
<h4 id="1-6-网页布局总结"><a href="#1-6-网页布局总结" class="headerlink" title="1.6. 网页布局总结"></a>1.6. 网页布局总结</h4><p>通过盒子模型，清楚知道大部分html标签是一个盒子。</p>
<p>通过CSS浮动、定位 可以让每个盒子排列成为网页。</p>
<p>一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法。</p>
<h5 id="1-6-1-标准流"><a href="#1-6-1-标准流" class="headerlink" title="1.6.1. 标准流"></a>1.6.1. 标准流</h5><p>可以让盒子上下排列或者左右排列，<strong>垂直的块级盒子显示就用标准流布局</strong>。</p>
<h5 id="1-6-2-浮动"><a href="#1-6-2-浮动" class="headerlink" title="1.6.2. 浮动"></a>1.6.2. 浮动</h5><p>可以让多个块级元素一行显示或者左右对齐盒子，<strong>多个块级盒子水平显示就用浮动布局</strong></p>
<h5 id="1-6-3-定位"><a href="#1-6-3-定位" class="headerlink" title="1.6.3. 定位"></a>1.6.3. 定位</h5><p>定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。<strong>如果元素自由在某个盒子内移动就用定位布局。</strong></p>
<h3 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h3><ul>
<li><p>目的（本质）</p>
<p>​    让一个元素在页面中消失或者显示出来</p>
</li>
<li><p>场景</p>
<p>​    类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！</p>
</li>
</ul>
<h4 id="1-display-显示（重点）"><a href="#1-display-显示（重点）" class="headerlink" title="1. display 显示（重点）"></a>1. display 显示（重点）</h4><ul>
<li><p>display 设置或检索对象是否及如何显示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: none 隐藏对象</span><br><span class="line"></span><br><span class="line">display：block 除了转换为块级元素之外，同时还有显示元素的意思。</span><br></pre></td></tr></table></figure></li>
<li><p>特点： display 隐藏元素后，<strong>不再占</strong>有原来的位置。</p>
</li>
<li><p>后面应用及其广泛，搭配 JS 可以做很多的网页特效。实际开发场景：</p>
<blockquote>
<p>配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</p>
</blockquote>
</li>
</ul>
<h4 id="2-visibility-可见性-（了解）"><a href="#2-visibility-可见性-（了解）" class="headerlink" title="2. visibility 可见性 （了解）"></a>2. visibility 可见性 （了解）</h4><ul>
<li><p>visibility 属性用于指定一个元素应可见还是隐藏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">visibility：visible ; 　元素可视</span><br><span class="line"></span><br><span class="line">visibility：hidden; 　  元素隐藏</span><br></pre></td></tr></table></figure></li>
<li><p>特点：<strong>visibility 隐藏元素后，继续占有原来的位置</strong>。（停职留薪）</p>
</li>
<li><p>如果隐藏元素想要原来位置， 就用 visibility：hidden</p>
</li>
<li><p>如果隐藏元素不想要原来位置， 就用 display：none  (用处更多 重点）</p>
</li>
</ul>
<h4 id="3-overflow-溢出（重点）"><a href="#3-overflow-溢出（重点）" class="headerlink" title="3. overflow 溢出（重点）"></a>3. overflow 溢出（重点）</h4><ul>
<li>overflow 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度） 时，会发生什么。</li>
</ul>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>visible</strong></td>
<td>不剪切内容也不添加滚动条</td>
</tr>
<tr>
<td><strong>hidden</strong></td>
<td>不显示超过对象尺寸的内容，超出的部分隐藏掉</td>
</tr>
<tr>
<td><strong>scroll</strong></td>
<td>不管超出内容否，总是显示滚动条</td>
</tr>
<tr>
<td><strong>auto</strong></td>
<td>超出自动显示滚动条，不超出不显示滚动条</td>
</tr>
</tbody></table>
<ul>
<li><p> 一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。</p>
</li>
<li><p> 但是如果有定位的盒子， 请慎用overflow:hidden  因为它会隐藏多余的部分。</p>
</li>
<li><p>实际开发场景：</p>
</li>
</ul>
<ol>
<li>清除浮动</li>
<li>隐藏超出内容，隐藏掉,  不允许内容超过父盒子。</li>
</ol>
<h4 id="4-显示与隐藏总结"><a href="#4-显示与隐藏总结" class="headerlink" title="4. 显示与隐藏总结"></a>4. 显示与隐藏总结</h4><table>
<thead>
<tr>
<th>属性</th>
<th>区别</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>display 显示     （重点）</strong></td>
<td>隐藏对象，不保留位置</td>
<td>配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</td>
</tr>
<tr>
<td><strong>visibility 可见性 （了解）</strong></td>
<td>隐藏对象，保留位置</td>
<td>使用较少</td>
</tr>
<tr>
<td><strong>overflow 溢出（重点）</strong></td>
<td>只是隐藏超出大小的部分</td>
<td>1. 可以清除浮动  2. 保证盒子里面的内容不会超出该盒子范围</td>
</tr>
</tbody></table>
<h3 id="css三角"><a href="#css三角" class="headerlink" title="css三角"></a>css三角</h3><p>网页中常见一些三角形，使用 CSS 直接画出来就可以，不必做成图片或者字体图标。</p>
<p>一张图， 你就知道 CSS 三角是怎么来的了, 做法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">0</span>; </span><br><span class="line">   <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-color</span>: red green blue black;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">0</span>;</span><br><span class="line">   <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>我们用css 边框可以模拟三角效果</li>
<li>宽度高度为0</li>
<li>我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了</li>
<li>为了照顾兼容性 低版本的浏览器，加上 font-size: 0;  line-height: 0;</li>
</ol>
<h3 id="CSS-用户界面样式"><a href="#CSS-用户界面样式" class="headerlink" title="CSS 用户界面样式"></a>CSS 用户界面样式</h3><p><strong>什么是界面样式</strong></p>
<p>所谓的界面样式，就是更改一些用户操作样式，以便提高更好的用户体验。</p>
<ul>
<li>更改用户的鼠标样式 </li>
<li>表单轮廓</li>
<li>防止表单域拖拽</li>
</ul>
<h4 id="鼠标样式-cursor"><a href="#鼠标样式-cursor" class="headerlink" title="鼠标样式 cursor"></a>鼠标样式 cursor</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">	<span class="attribute">cursor</span>: pointer; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</p>
<h4 id="轮廓线-outline"><a href="#轮廓线-outline" class="headerlink" title="轮廓线 outline"></a>轮廓线 outline</h4><p>给表单添加 outline: 0;   或者  outline: none; 样式之后，就可以去掉默认的蓝色边框。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">	<span class="attribute">outline</span>: none; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="防止拖拽文本域-resize"><a href="#防止拖拽文本域-resize" class="headerlink" title="防止拖拽文本域 resize"></a>防止拖拽文本域 resize</h4><p> 实际开发中，我们文本域右下角是不可以拖拽的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">textarea</span>&#123; </span><br><span class="line">	<span class="attribute">resize</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vertical-align-属性应用"><a href="#vertical-align-属性应用" class="headerlink" title="vertical-align 属性应用"></a>vertical-align 属性应用</h4><p>CSS 的 <strong>vertical-align</strong> 属性使用场景： 经常用于设置图片或者表单(行内块元素）和文字垂直对齐。</p>
<p>官方解释： 用于设置一个元素的<strong>垂直对齐方式</strong>，但是它只针对于行内元素或者行内块元素有效。</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vertical-align</span> : baseline | top | middle | bottom </span><br></pre></td></tr></table></figure>

<h4 id="图片、表单和文字对齐"><a href="#图片、表单和文字对齐" class="headerlink" title="图片、表单和文字对齐"></a><strong>图片、表单和文字对齐</strong></h4><p>图片、表单都属于行内块元素，默认的 vertical-align 是基线对齐。</p>
<p>此时可以给图片、表单这些行内块元素的 <strong>vertical-align 属性设置为 middle</strong> 就可以让文字和图片垂直居中对齐了。</p>
<h4 id="解决图片底部默认空白缝隙问题"><a href="#解决图片底部默认空白缝隙问题" class="headerlink" title="解决图片底部默认空白缝隙问题"></a>解决图片底部默认空白缝隙问题</h4><p>bug：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐。</p>
<p>主要解决方法有两种：</p>
<p>1.<strong>给图片</strong>添加 <strong>vertical-align:middle | top| bottom</strong> 等。 （提倡使用的）</p>
<p>2.把图片转换为块级元素  <strong>display: block</strong>; </p>
<h4 id="溢出的文字省略号显示"><a href="#溢出的文字省略号显示" class="headerlink" title="溢出的文字省略号显示"></a>溢出的文字省略号显示</h4><h5 id="1-单行文本溢出显示省略号"><a href="#1-单行文本溢出显示省略号" class="headerlink" title="1 单行文本溢出显示省略号"></a>1 单行文本溢出显示省略号</h5><p>单行文本溢出显示省略号–必须满足三个条件：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1. 先强制一行内显示文本*/</span></span><br><span class="line"> <span class="attribute">white-space</span>: nowrap;  （ 默认 <span class="attribute">normal</span> 自动换行）</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*2. 超出的部分隐藏*/</span></span><br><span class="line"> <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*3. 文字用省略号替代超出的部分*/</span></span><br><span class="line"> <span class="attribute">text-overflow</span>: ellipsis;</span><br></pre></td></tr></table></figure>

<h5 id="2-多行文本溢出显示省略号（了解）"><a href="#2-多行文本溢出显示省略号（了解）" class="headerlink" title="2 多行文本溢出显示省略号（了解）"></a>2 多行文本溢出显示省略号（了解）</h5><p>多行文本溢出显示省略号，<strong>有较大兼容性问题</strong>，适合于webKit浏览器或移动端（移动端大部分是webkit内核）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1. 超出的部分隐藏 */</span></span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2. 文字用省略号替代超出的部分 */</span></span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 弹性伸缩盒子模型显示 */</span></span><br><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4. 限制在一个块元素显示的文本的行数 */</span></span><br><span class="line">-webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5. 设置或检索伸缩盒对象的子元素的排列方式 */</span></span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure>

<p><strong>更推荐让后台人员来做这个效果，因为后台人员可以设置显示多少个字，操作更简单。</strong></p>
<h3 id="CSS-初始化"><a href="#CSS-初始化" class="headerlink" title="CSS 初始化"></a>CSS 初始化</h3><p>不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对HTML文本呈现的差异，照顾浏览器的兼容，我们需要对CSS 初始化</p>
<p>简单理解： CSS初始化是指重设浏览器的样式。 (也称为CSS reset）</p>
<p>每个网页都必须首先进行 CSS初始化。</p>
<p>这里我们以 京东CSS初始化代码为例。</p>
<p><strong>Unicode编码字体：</strong></p>
<p>把中文字体的名称用相应的Unicode编码来代替，这样就可以有效的避免浏览器解释CSS代码时候出现乱码的问题。</p>
<p>比如：</p>
<p>黑体 \9ED1\4F53<br>宋体 \5B8B\4F53<br>微软雅黑 \5FAE\8F6F\96C5\9ED1</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/HtmlCss%E5%9F%BA%E7%A1%80/" data-id="ckomi7m4t000ao6513esx1idk" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/13/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/05/12/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/05/10/%E5%AD%A6%E4%B9%A0%E3%80%81%E6%8F%92%E4%BB%B6%E7%BD%91%E5%9D%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/05/10/leetcode%E5%88%B7%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/05/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>